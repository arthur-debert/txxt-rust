Parser Implementation Developer Cheatsheet

Quick reference guide for implementing parser tasks following the master plan.

1. Before You Start

    Read these files first:
    - docs/specs/core/terminology.txxt - Element hierarchy (Span/Line/Block/Container)
    - docs/specs/elements/<element>.txxt - Spec for element you're implementing
    - docs/dev/parser-core/Parser-1.4.1-per-element-corpora.txxt - Test labels
    
    Understand the pipeline:
        Raw Text → Tokens → Blocks → Elements → AST → Document

2. Implementation Workflow

    Step 1: Load test corpus
        use tests::corpora::TxxtCorpora;
        let corpus = TxxtCorpora::load("txxt.core.spec.paragraph.valid.simple")?;
        
    Step 2: Write failing test
        #[test]
        fn test_parse_simple_paragraph() {
            let corpus = TxxtCorpora::load("txxt.core.spec.paragraph.valid.simple").unwrap();
            let result = parse_paragraph(&corpus.source_text);
            assert!(result.is_ok());
        }
        
    Step 3: Implement parser logic
        - Check src/parser/elements/<element>.rs
        - Follow spec rules exactly
        - Use existing AST types from src/ast/elements/
        
    Step 4: Run test, iterate
        cargo test test_parse_simple_paragraph
        
    Step 5: Validate with ensemble
        cargo test --test ensemble_documents_example
        
    Step 6: Implement element assertion (~30 minutes)
        - Copy assert_paragraph() from tests/assertions/mod.rs as template
        - Update for your element type (e.g., assert_list())
        - Reuse shared validators from validators.rs
        - Add assertion tests to assertion_framework_tests.rs

3. Key APIs

    3.1. Load Test Data
    
        Fragments (isolated elements):
            TxxtCorpora::load("txxt.core.spec.element.validity.case")
            
        Full documents:
            TxxtCorpora::load_document("01-two-paragraphs")
            TxxtCorpora::load_document("11")  // Prefix match
            
        Error cases:
            let corpus = TxxtCorpora::load("txxt.core.spec.element.invalid.case")?;
            assert!(corpus.is_error_case());
            assert_eq!(corpus.expected_error(), Some("ErrorType"));
    
    3.2. AST Types (from src/ast/elements/)
    
        Blocks:
            - ParagraphBlock { content, annotations, tokens, parameters }
            - ListBlock { decoration_type, items, annotations, tokens }
            - DefinitionBlock { term, content, parameters, annotations, tokens }
            - VerbatimBlock { title, content, label, parameters, verbatim_type, annotations, tokens }
            - SessionBlock { title, content, annotations, tokens }
            - AnnotationBlock { label, parameters, content, tokens }
            
        Containers:
            - ContentContainer { content: Vec<ContentContainerElement>, ... }
            - SessionContainer { content: Vec<SessionContainerElement>, ... }
            - IgnoreContainer { ignore_lines, blank_lines }
            
        Inlines:
            - TextTransform enum (Identity, Strong, Emphasis, Code, Math, ...)
            - BoldSpan, ItalicSpan, CodeSpan, MathSpan
            - ReferenceSpan, CitationSpan, etc.
    
    3.3. Tree Traversal (from src/ast/traversal.rs)
    
        Build tree:
            let traversable = TraversableDocument::from_document(&doc);
            
        Query:
            let paragraphs = traversable.query()
                .find_by_type(ElementType::Block)
                .collect();
                
        XPath:
            let results = traversable.xpath("//Block")?;

4. Testing Patterns

    4.1. Basic Element Test
    
        #[test]
        fn test_element_simple() {
            let corpus = TxxtCorpora::load("txxt.core.spec.element.valid.simple").unwrap();
            let result = parse_element(&corpus.source_text);
            
            assert!(result.is_ok());
            let element = result.unwrap();
            
            // Validate structure
            assert_eq!(element.element_type(), ElementType::Block);
            // Validate content
            // Validate tokens
        }
    
    4.2. Error Case Test
    
        #[test]
        fn test_element_invalid() {
            let corpus = TxxtCorpora::load("txxt.core.spec.element.invalid.case").unwrap();
            assert!(corpus.is_error_case());
            
            let result = parse_element(&corpus.source_text);
            assert!(result.is_err());
            
            if let Err(error) = result {
                assert!(error.to_string().contains(corpus.expected_error().unwrap()));
            }
        }
    
    4.3. Snapshot Test
    
        #[test]
        fn test_element_snapshot() {
            let corpus = TxxtCorpora::load("txxt.core.spec.element.valid.complex").unwrap();
            let ast = parse_element(&corpus.source_text).unwrap();
            
            insta::assert_yaml_snapshot!(ast);
        }
    
    4.4. Progressive Document Test
    
        #[test]
        fn test_progressive_parsing() {
            // Start simple
            let doc01 = TxxtCorpora::load_document("01").unwrap();
            assert!(parse_document(&doc01.source_text).is_ok());
            
            // Add complexity
            let doc05 = TxxtCorpora::load_document("05").unwrap();
            assert!(parse_document(&doc05.source_text).is_ok());
            
            // Full feature
            let doc11 = TxxtCorpora::load_document("11").unwrap();
            assert!(parse_document(&doc11.source_text).is_ok());
        }

5. Writing Custom Assertions

    5.1. Using Existing Assertions
    
        For paragraphs (already implemented):
            use tests::assertions::{assert_paragraph, ParagraphExpected};
            
            let paragraph = parse_paragraph(&corpus.source_text)?;
            let element = SessionContainerElement::Paragraph(paragraph);
            
            assert_paragraph(&element, ParagraphExpected {
                text: Some("Expected exact text"),
                has_formatting: Some(true),
                annotation_count: Some(2),
                ..Default::default()
            });
    
    5.2. Implementing Your Element's Assertion
    
        Time required: ~30 minutes per element
        
        Step 1: Open tests/assertions/mod.rs
        
        Step 2: Find your element's stub function (e.g., assert_list())
        
        Step 3: Copy assert_paragraph() as template:
            - Replace Paragraph with your element type
            - Replace ParagraphExpected with your element's Expected struct
            - Update the downcast match arm
            - Implement element-specific validation
            
        Step 4: Reuse shared validators:
            - validate_text_exact() - Exact text matching
            - validate_text_contains() - Substring matching
            - validate_text_matches() - Regex matching
            - validate_parameter() - Parameter validation
            - validate_annotation_count() - Annotation counting
            - validate_has_annotation() - Annotation presence
            - validate_has_formatting() - Formatting detection
            
        Step 5: Add tests to assertion_framework_tests.rs:
            #[test]
            fn test_assert_list_basic() {
                let list = make_test_list("- Item 1\n- Item 2");
                assert_list(&list, ListExpected {
                    item_count: Some(2),
                    style: Some(NumberingStyle::Plain),
                    ..Default::default()
                });
            }
    
    5.3. Expected Struct Usage (Builder Pattern)
    
        All fields are optional - only specify what you want to validate:
        
            // Test just item count
            ListExpected {
                item_count: Some(3),
                ..Default::default()
            }
            
            // Test multiple properties
            DefinitionExpected {
                term: Some("API"),
                content_count: Some(2),
                has_annotation: Some("note"),
                ..Default::default()
            }
            
            // Test everything
            SessionExpected {
                title: Some("Introduction"),
                is_numbered: Some(true),
                numbering: Some("1"),
                child_count: Some(5),
                has_subsession: Some(true),
                ..Default::default()
            }
    
    5.4. Assertion Testing Patterns
    
        Test both success and failure cases:
        
            #[test]
            fn test_assert_element_succeeds() {
                let element = make_test_element("valid content");
                // Should not panic
                assert_element(&element, ElementExpected {
                    text: Some("valid content"),
                    ..Default::default()
                });
            }
            
            #[test]
            #[should_panic(expected = "Text mismatch")]
            fn test_assert_element_fails() {
                let element = make_test_element("actual content");
                // Should panic with clear message
                assert_element(&element, ElementExpected {
                    text: Some("wrong content"),
                    ..Default::default()
                });
            }
    
    5.5. Integration with Parser Tests
    
        Use assertions in your parser tests for comprehensive validation:
        
            #[test]
            fn test_parse_list_with_validation() {
                let corpus = TxxtCorpora::load("txxt.core.spec.list.valid.simple").unwrap();
                let result = parse_list(&corpus.source_text).unwrap();
                
                let element = SessionContainerElement::List(result);
                assert_list(&element, ListExpected {
                    item_count: Some(3),
                    style: Some(NumberingStyle::Plain),
                    item_text: Some(vec!["First", "Second", "Third"]),
                    ..Default::default()
                });
            }

6. Common Patterns

    6.1. Element Recognition
    
        Pattern matching order (highest to lowest priority):
        1. Annotations (:: label ::)
        2. Verbatim (title:)
        3. Definitions (term ::)
        4. Lists (- item, 1. item)
        5. Sessions (title + indented content)
        6. Paragraphs (default fallback)
    
    6.2. Container Creation
    
        When to use ContentContainer:
        - List item nested content
        - Definition content
        - Annotation block content
        - Cannot contain sessions
        
        When to use SessionContainer:
        - Document root
        - Session content
        - Can contain sessions
    
    6.3. Indentation Rules
    
        - All indentation is multiples of 4 spaces
        - Children are +1 level from parent (parent + 4 spaces)
        - Containers get indented, not their parent elements
        - Session title at N, content at N+4
        - List item at N, nested content at N+4

7. Debugging Tips

    7.1. When Tests Fail
    
        Check this order:
        1. Corpus loaded correctly? Print corpus.source_text
        2. Tokenization correct? Use tokenizer debug output
        3. Block grouping correct? Check indentation detection
        4. Element recognition correct? Check pattern matching
        5. AST structure correct? Use ast_debug visualization
        
    7.2. Use Tree Visualization
    
        use txxt::ast_debug::AstTreeVisualizer;
        
        let doc = parse_document(&source)?;
        let viz = AstTreeVisualizer::new();
        println!("{}", viz.visualize(&doc));
    
    7.3. Use Traversal for Inspection
    
        let traversable = TraversableDocument::from_document(&doc);
        let stats = traversable.element_type_stats();
        println!("Elements: {:?}", stats);

8. Commit Workflow

    8.1. Commit Message Format
    
        Pattern: Parser <step-number> <element> <details>
        
        Examples:
            Parser 2.1.1 Paragraph simple form implementation
            Parser 2.1.5 Session container flat structure
            Parser 2.2.3 Definition invalid cases handling
    
    8.2. Before Each Commit
    
        Checklist:
        - [ ] All tests pass (cargo test)
        - [ ] No clippy warnings (cargo clippy)
        - [ ] Code formatted (rustfmt)
        - [ ] Documentation updated
        - [ ] Snapshot tests updated if needed
    
    8.3. PR Creation
    
        Title: Parser <release>.<milestone> <milestone-title>
        Example: "Parser 1.2 Inspection Tooling"
        
        Body must include:
        - Completed steps with commit links
        - Test coverage summary
        - References to related issues

9. Quick Reference

    Assertion files:
        Expected structs: tests/assertions/expected.rs
        Validators: tests/assertions/validators.rs
        Assertions: tests/assertions/mod.rs
        Assertion tests: tests/assertion_framework_tests.rs
        Implementation guide: tests/assertions/README.md
        

    File locations:
        Specs: docs/specs/elements/<element>.txxt
        AST types: src/ast/elements/<element>.rs
        Parser impl: src/parser/elements/<element>.rs
        Tests: tests/<element>_parser_tests.rs
        Corpora labels: docs/dev/parser-core/Parser-1.4.1-per-element-corpora.txxt
        Ensembles: docs/specs/ensembles/NN-name.txxt
        
    Commands:
        cargo test <element>_parser  # Run element tests
        cargo test --test ensemble_documents_example  # Integration tests
        cargo clippy --all-targets --all-features  # Lint check
        cargo test --test assertion_framework_tests  # Test assertions
        just test  # Run test suite (if using justfile)

10. Common Pitfalls

    ❌ Don't anticipate future work
    ❌ Don't skip validation steps
    ❌ Don't break existing tests
    ❌ Don't commit with failing tests
    ❌ Don't merge without PR review
    
    ✅ Do follow spec exactly
    ✅ Do test progressively
    ✅ Do use corpora system
    ✅ Do validate with ensembles
    ✅ Do update docs when needed
    ✅ Do implement assertions for your element

11. Getting Help

    When stuck:
    1. Review the element spec again
    2. Check similar element implementation
    3. Look at existing tests for patterns
    4. Use tree visualization to inspect output
    5. Review corpora extraction to verify test data
    
    Resources:
    - tests/ensemble_documents_example.rs - Test patterns
    - tests/assertion_framework_tests.rs - Assertion examples
    - tests/assertions/mod.rs - assert_paragraph() reference implementation
    - src/ast_debug.rs - Visualization tools
    - docs/dev/parser-core/PLAN-REVIEW.txxt - Plan analysis

:: note :: This cheatsheet provides quick reference for parser implementation. Keep it open while coding for faster lookup.

