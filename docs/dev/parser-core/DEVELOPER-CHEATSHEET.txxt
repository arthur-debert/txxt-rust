Parser Implementation Developer Cheatsheet

Quick reference guide for implementing parser tasks following the master plan.

1. Before You Start

    Read these files first:
    - docs/specs/core/terminology.txxt - Element hierarchy (Span/Line/Block/Container)
    - docs/specs/elements/<element>.txxt - Spec for element you're implementing
    - docs/dev/parser-core/Parser-1.4.1-per-element-corpora.txxt - Test labels
    - docs/dev/parser-core/core-parser-implementation-plan.txxt - Overall implementation plan
    
    Understand the pipeline:
        Raw Text → Tokens → TokenTree → AST Elements → Document

2. Implementation Guides

    Choose the appropriate guide for your work:
    
    2.1. Single Element Simple Implementation
        - Location: docs/dev/parser-core/single-element-simple-guide.txxt
        - Use for: Implementing individual element types in simple forms
        - Focus: Element isolation, assertion validation, basic functionality
        
    2.2. Mixed Ensemble Implementation  
        - Location: docs/dev/parser-core/mixed-ensemble-guide.txxt
        - Use for: Testing elements together in realistic document structures
        - Focus: Element interactions, nesting, content preservation
        
    2.3. Complex Element Implementation
        - Location: docs/dev/parser-core/complex-element-guide.txxt
        - Use for: Complex parameter parsing, edge cases, advanced features
        - Focus: Parameter parsing, nested formatting, deep nesting

3. Current Implementation Status

    3.1. Completed Infrastructure ✅
    
        - Lexer (Phase 1): Complete with token tree building
        - AST Types: All element types defined
        - Assertion Framework: Complete for all elements (needs validation with real data)
        - Corpora System: Test data organized by element and complexity
        - Assembler (Phase 3): Complete
        
    3.2. Parser Implementation Status 🔄
    
        - Block Parser: Structured but not implemented
        - Inline Parser: Structured but not implemented
        - Element-specific parsing: Not implemented
        - Integration testing: Not implemented
        
    3.3. Key Implementation Notes
    
        - Parser is designed to be stateless (uses TokenTree from lexer)
        - Position tracking is handled by lexer (tokens include Position info)
        - Block grouping is handled by lexer (TokenTree provides hierarchy)
        - Assertions exist but need validation with real parsed data

4. Key APIs

    4.1. Load Test Data
    
        Fragments (isolated elements):
            TxxtCorpora::load("txxt.core.spec.element.validity.case")
            
        Full documents:
            TxxtCorpora::load_document("01-two-paragraphs")
            TxxtCorpora::load_document("11")  // Prefix match
            
        Error cases:
            let corpus = TxxtCorpora::load("txxt.core.spec.element.invalid.case")?;
            assert!(corpus.is_error_case());
            assert_eq!(corpus.expected_error(), Some("ErrorType"));
    
    4.2. Parser Pipeline APIs
    
        Current parser structure (src/parser/pipeline/):
            BlockParser::new().parse_blocks(token_tree) -> Vec<ElementNode>
            InlineParser::new().parse_inlines(blocks) -> Vec<ElementNode>
            
        Lexer integration:
            let tokens = tokenize(input_text);
            let token_tree = TokenTreeBuilder::new().build_tree(tokens)?;
            
        Assembler integration:
            let document = Assembler::new().assemble_document(ast)?;
    
    4.3. AST Types (from src/ast/elements/)
    
        Blocks:
            - ParagraphBlock { content, annotations, tokens, parameters }
            - ListBlock { decoration_type, items, annotations, tokens }
            - DefinitionBlock { term, content, parameters, annotations, tokens }
            - VerbatimBlock { title, content, label, parameters, verbatim_type, annotations, tokens }
            - SessionBlock { title, content, annotations, tokens }
            - AnnotationBlock { label, parameters, content, tokens }
            
        Containers:
            - ContentContainer { content: Vec<ContentContainerElement>, ... }
            - SessionContainer { content: Vec<SessionContainerElement>, ... }
            - IgnoreContainer { ignore_lines, blank_lines }
            
        Inlines:
            - TextTransform enum (Identity, Strong, Emphasis, Code, Math, ...)
            - BoldSpan, ItalicSpan, CodeSpan, MathSpan
            - ReferenceSpan, CitationSpan, etc.
    
    4.4. Assertion Framework (from tests/assertions/)
    
        Element assertions (all implemented, need validation with real data):
            assert_paragraph(element, ParagraphExpected { ... })
            assert_list(element, ListExpected { ... })
            assert_definition(element, DefinitionExpected { ... })
            assert_session(element, SessionExpected { ... })
            assert_verbatim(element, VerbatimExpected { ... })
            assert_annotation(element, AnnotationExpected { ... })
            
        Shared validators:
            validate_text_exact(content, expected)
            validate_text_contains(content, needle)
            validate_parameter(parameters, key, value)
            validate_annotation_count(annotations, count)
            validate_has_formatting(content, has_formatting)
    
    4.5. Tree Traversal (from src/ast/traversal.rs)
    
        Build tree:
            let traversable = TraversableDocument::from_document(&doc);
            
        Query:
            let paragraphs = traversable.query()
                .find_by_type(ElementType::Block)
                .collect();
                
        XPath:
            let results = traversable.xpath("//Block")?;

6. Testing Patterns

    6.1. Basic Element Test
    
        #[test]
        fn test_element_simple() {
            let corpus = TxxtCorpora::load("txxt.core.spec.element.valid.simple").unwrap();
            let result = parse_element(&corpus.source_text);
            
            assert!(result.is_ok());
            let element = result.unwrap();
            
            // Validate structure
            assert_eq!(element.element_type(), ElementType::Block);
            // Validate content
            // Validate tokens
        }
    
    6.2. Error Case Test
    
        #[test]
        fn test_element_invalid() {
            let corpus = TxxtCorpora::load("txxt.core.spec.element.invalid.case").unwrap();
            assert!(corpus.is_error_case());
            
            let result = parse_element(&corpus.source_text);
            assert!(result.is_err());
            
            if let Err(error) = result {
                assert!(error.to_string().contains(corpus.expected_error().unwrap()));
            }
        }
    
    6.3. Snapshot Test
    
        #[test]
        fn test_element_snapshot() {
            let corpus = TxxtCorpora::load("txxt.core.spec.element.valid.complex").unwrap();
            let ast = parse_element(&corpus.source_text).unwrap();
            
            insta::assert_yaml_snapshot!(ast);
        }
    
    6.4. Progressive Document Test
    
        #[test]
        fn test_progressive_parsing() {
            // Start simple
            let doc01 = TxxtCorpora::load_document("01").unwrap();
            assert!(parse_document(&doc01.source_text).is_ok());
            
            // Add complexity
            let doc05 = TxxtCorpora::load_document("05").unwrap();
            assert!(parse_document(&doc05.source_text).is_ok());
            
            // Full feature
            let doc11 = TxxtCorpora::load_document("11").unwrap();
            assert!(parse_document(&doc11.source_text).is_ok());
        }

7. Writing Custom Assertions

    7.1. Using Existing Assertions
    
        For paragraphs (already implemented):
            use tests::assertions::{assert_paragraph, ParagraphExpected};
            
            let paragraph = parse_paragraph(&corpus.source_text)?;
            let element = SessionContainerElement::Paragraph(paragraph);
            
            assert_paragraph(&element, ParagraphExpected {
                text: Some("Expected exact text"),
                has_formatting: Some(true),
                annotation_count: Some(2),
                ..Default::default()
            });
    
    7.2. Validating Assertions with Real Data
    
        **Critical**: Existing assertions are based on spec + AST definitions, not real data.
        You must validate and fix them during implementation.
        
        ```rust
        #[test]
        fn test_<element>_assertions_with_real_data() {
            let corpus = TxxtCorpora::load("txxt.core.spec.<element>.valid.simple").unwrap();
            let element = parse_<element>(&corpus.source_text).unwrap();
            
            // Test assertion with real data
            let container_element = SessionContainerElement::<Element>(element);
            assert_<element>(&container_element, <Element>Expected {
                // Test with actual values from corpus
                ..Default::default()
            });
        }
        ```
    
    5.3. Expected Struct Usage (Builder Pattern)
    
        All fields are optional - only specify what you want to validate:
        
            // Test just item count
            ListExpected {
                item_count: Some(3),
                ..Default::default()
            }
            
            // Test multiple properties
            DefinitionExpected {
                term: Some("API"),
                content_count: Some(2),
                has_annotation: Some("note"),
                ..Default::default()
            }
            
            // Test everything
            SessionExpected {
                title: Some("Introduction"),
                is_numbered: Some(true),
                numbering: Some("1"),
                child_count: Some(5),
                has_subsession: Some(true),
                ..Default::default()
            }
    
    5.4. Assertion Testing Patterns
    
        Test both success and failure cases:
        
            #[test]
            fn test_assert_element_succeeds() {
                let element = make_test_element("valid content");
                // Should not panic
                assert_element(&element, ElementExpected {
                    text: Some("valid content"),
                    ..Default::default()
                });
            }
            
            #[test]
            #[should_panic(expected = "Text mismatch")]
            fn test_assert_element_fails() {
                let element = make_test_element("actual content");
                // Should panic with clear message
                assert_element(&element, ElementExpected {
                    text: Some("wrong content"),
                    ..Default::default()
                });
            }
    
    5.5. Integration with Parser Tests
    
        Use assertions in your parser tests for comprehensive validation:
        
            #[test]
            fn test_parse_list_with_validation() {
                let corpus = TxxtCorpora::load("txxt.core.spec.list.valid.simple").unwrap();
                let result = parse_list(&corpus.source_text).unwrap();
                
                let element = SessionContainerElement::List(result);
                assert_list(&element, ListExpected {
                    item_count: Some(3),
                    style: Some(NumberingStyle::Plain),
                    item_text: Some(vec!["First", "Second", "Third"]),
                    ..Default::default()
                });
            }

8. Common Patterns

    8.1. Element Recognition
    
        Pattern matching order (highest to lowest priority):
        1. Annotations (:: label ::)
        2. Verbatim (title:)
        3. Definitions (term ::)
        4. Lists (- item, 1. item)
        5. Sessions (title + indented content)
        6. Paragraphs (default fallback)
    
    8.2. Container Creation
    
        When to use ContentContainer:
        - List item nested content
        - Definition content
        - Annotation block content
        - Cannot contain sessions
        
        When to use SessionContainer:
        - Document root
        - Session content
        - Can contain sessions
    
    8.3. Indentation Rules
    
        - All indentation is multiples of 4 spaces
        - Children are +1 level from parent (parent + 4 spaces)
        - Containers get indented, not their parent elements
        - Session title at N, content at N+4
        - List item at N, nested content at N+4

9. Debugging Tips

    9.1. When Tests Fail
    
        Check this order:
        1. Corpus loaded correctly? Print corpus.source_text
        2. Tokenization correct? Use tokenizer debug output
        3. Block grouping correct? Check indentation detection
        4. Element recognition correct? Check pattern matching
        5. AST structure correct? Use ast_debug visualization
        
    9.2. Use Tree Visualization
    
        use txxt::ast_debug::AstTreeVisualizer;
        
        let doc = parse_document(&source)?;
        let viz = AstTreeVisualizer::new();
        println!("{}", viz.visualize(&doc));
    
    9.3. Use Traversal for Inspection
    
        let traversable = TraversableDocument::from_document(&doc);
        let stats = traversable.element_type_stats();
        println!("Elements: {:?}", stats);

10. Commit Workflow

    10.1. Commit Message Format
    
        Pattern: Parser <step-number> <element> <details>
        
        Examples:
            Parser 2.1.1 Paragraph simple form implementation
            Parser 2.1.5 Session container flat structure
            Parser 2.2.3 Definition invalid cases handling
    
    10.2. Before Each Commit
    
        Checklist:
        - [ ] All tests pass (cargo test)
        - [ ] No clippy warnings (cargo clippy)
        - [ ] Code formatted (rustfmt)
        - [ ] Documentation updated
        - [ ] Snapshot tests updated if needed
    
    10.3. PR Creation
    
        Title: Parser <release>.<milestone> <milestone-title>
        Example: "Parser 1.2 Inspection Tooling"
        
        Body must include:
        - Completed steps with commit links
        - Test coverage summary
        - References to related issues

11. Quick Reference

    11.1. Implementation Guides
        Single Element Simple: docs/dev/parser-core/single-element-simple-guide.txxt
        Mixed Ensemble: docs/dev/parser-core/mixed-ensemble-guide.txxt
        Complex Element: docs/dev/parser-core/complex-element-guide.txxt
        Core Implementation Plan: docs/dev/parser-core/core-parser-implementation-plan.txxt
        
    11.2. File Locations
        Specs: docs/specs/elements/<element>.txxt
        AST types: src/ast/elements/<element>.rs
        Parser impl: src/parser/pipeline/parse_blocks.rs, parse_inlines.rs
        Tests: tests/<element>_parser_tests.rs
        Corpora labels: docs/dev/parser-core/Parser-1.4.1-per-element-corpora.txxt
        Ensembles: docs/specs/ensembles/NN-name.txxt
        
    11.3. Commands
        cargo test <element>_parser  # Run element tests
        cargo test --test ensemble_documents_example  # Integration tests
        cargo clippy --all-targets --all-features  # Lint check
        cargo test --test assertion_framework_tests  # Test assertions
        just test  # Run test suite (if using justfile)

12. Common Pitfalls

    ❌ Don't anticipate future work
    ❌ Don't skip validation steps
    ❌ Don't break existing tests
    ❌ Don't commit with failing tests
    ❌ Don't merge without PR review
    ❌ Don't assume existing assertions are correct
    
    ✅ Do follow spec exactly
    ✅ Do test progressively
    ✅ Do use corpora system
    ✅ Do validate with ensembles
    ✅ Do update docs when needed
    ✅ Do validate assertions with real data
    ✅ Do fix assertion implementations

13. Getting Help

    When stuck:
    1. Review the element spec again
    2. Check similar element implementation
    3. Look at existing tests for patterns
    4. Use tree visualization to inspect output
    5. Review corpora extraction to verify test data
    6. Check assertion implementation for your element
    
    Resources:
    - Implementation guides (see Quick Reference)
    - tests/ensemble_documents_example.rs - Test patterns
    - tests/assertion_framework_tests.rs - Assertion examples
    - tests/assertions/mod.rs - assert_paragraph() reference implementation
    - src/ast_debug.rs - Visualization tools
    - docs/dev/parser-core/PLAN-REVIEW.txxt - Plan analysis

:: note :: This cheatsheet provides quick reference for parser implementation. Keep it open while coding for faster lookup.

