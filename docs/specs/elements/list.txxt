:: title :: List Element Specification
:: author :: Arthur Debert
:: pub-date :: 2025-01-12

Complete specification for lists - ordered and unordered collections of items with sophisticated styling and nesting support.

1. Purpose

    Lists provide structured collections of related items with support for complex numbering schemes, nesting, and flexible authoring patterns. Lists in txxt are designed for technical documentation needs, supporting everything from simple bullet points to complex hierarchical outlines with mixed numbering styles.

2. Syntax

    2.1. Basic List Styles

        Plain style list:
            - First item
            - Second item
            - Third item
        (plain)

        Numerical style list:
            1. First item
            2. Second item
            3. Third item
        (numerical)

        Alphabetical style list:
            a. First item
            b. Second item
            c. Third item
        (alphabetical)

        Roman style list:
            i. First item
            ii. Second item
            iii. Third item
        (roman)

    2.2. Marker Variations

        Numerical formats:
            1. Period format (canonical)
            1) Parenthesis format
        (numerical)

        Alphabetical formats:
            a. Lowercase with period
            A. Uppercase with period
            a) Lowercase with parenthesis
            A) Uppercase with parenthesis
        (alphabetical-formats)

        Roman numeral formats:
            i. Lowercase roman with period
            I. Uppercase roman with period
            i) Lowercase roman with parenthesis
            I) Uppercase roman with parenthesis
        (roman-formats)

    2.3. Nested Lists

        Mixed styling across levels:
            1. Groceries
                - Milk
                - Bread
                    a. Whole wheat
                    b. Sourdough
                - Eggs
            2. Hardware store
                - Screws
                - Paint
        (nested)

3. Grammar

    3.1. List Markers

        List markers use sequence marker patterns as defined in [syntax.txxt]. The complete sequence marker grammar includes plain, numerical, alphabetical, and roman styles with period and parenthesis forms.

        For the complete sequence marker grammar including `<sequence-marker>`, `<plain-marker>`, `<numerical-marker>`, `<alphabetical-marker>`, and `<roman-marker>` definitions, see [syntax.txxt] section 4.1.

    3.2. List Structure

        A list is a collection of one or more list items. Nested content is handled by a following container, not as part of the list item itself.

            <list> = <list-item>+
            <list-item> = <sequence-marker> <list-item-content>
            <list-item-content> = <text-line>
        
        **Critical Rule**: Single items at the top level are parsed as paragraphs, not lists. Lists require multiple items at the root level to disambiguate from dialog and ensure clear intent. However, single items are allowed within nested contexts.
        :: grammar

4. AST Structure

    Post-parsing semantic representation:

    List AST:
        ├── List
        │   ├── decoration_type: ListDecorationType
        │   │   ├── style: NumberingStyle
        │   │   └── form: NumberingForm
        │   ├── items: Vec<ListItem>
        │   ├── annotations: Vec<Annotation>
        │   └── tokens: TokenSequence
    (tree)

    List Item AST:
        ├── ListItem
        │   ├── marker: String (preserved exactly)
        │   ├── content: Vec<Inline>
        │   ├── nested: Option<Container>
        │   ├── annotations: Vec<Annotation>
        │   └── tokens: TokenSequence
    (tree)

    Numbering styles and forms:
        NumberingStyle: Plain | Numerical | AlphabeticalLower | AlphabeticalUpper | RomanLower | RomanUpper
        NumberingForm: Short | Full
    (enums)

5. Styling and Decoration

    5.1. Style Determination

        List style rules:
        - First item determines style: Style of first list item sets style for entire list
        - Marker preservation: Original markers preserved exactly for source reconstruction
        - No validation: Mixed or incorrect numbering accepted without error
        - Forgiving parsing: Content preserved, inconsistencies noted but not rejected

    5.2. List Forms

        Short form (local numbering):
            1. First
            2. Second
                a. Nested first
                b. Nested second
            3. Third
        (short-form)

        Extended form (hierarchical numbering):
            1. First
            2. Second
                2.a. Nested first
                2.b. Nested second  
            3. Third
        (extended-form)

        Form determination is based on the actual markers used in the source.

    5.3. Templated Numbering

        All items numbered as "1." for easy editing:
            1. First item
            1. Second item (written as 1.)
            1. Third item (written as 1.)
        (templated)

        This pattern allows easy insertion/deletion without renumbering.

6. Processing Rules

    Lists follow the standard processing pattern defined in [common-processing.txxt] with the following element-specific requirements:

    6.1. Recognition Criteria

        List-specific detection requirements:
        - **Multiple items required**: Single items at top level are parsed as paragraphs (graceful degradation)
        - **Nested single items allowed**: Single items are valid within nested containers
        - Consistent indentation: All items at same level
        - Valid markers: Must match sequence marker patterns defined in [syntax.txxt]
        - Content requirement: Each item must have content

    6.2. Style Processing

        List-specific numbering style handling:
        1. Parse first item marker using standard sequence marker patterns
        2. Determine NumberingStyle and NumberingForm from first item
        3. Apply style to entire list (first item determines style)
        4. Preserve all original markers exactly for source reconstruction
        5. Note but don't reject style inconsistencies (forgiving parsing)

    6.3. Nesting Processing

        List-specific nested content handling:
        1. Detect indentation increase after list item
        2. Create Content Container for nested content (standard container rules)
        3. Apply standard recursive parsing to nested content
        4. Allow any content type except sessions (standard Content Container restrictions)

7. Edge Cases

    7.1. Single Item Lists at Top Level

        **CRITICAL RULE**: Single items at the top level are never lists:
        
        Not a list (parsed as paragraph):
            - Call mom.
        (single-item)

        This is parsed as a paragraph, not a list, to avoid ambiguity with dialog and ensure clear authoring intent. Lists must have multiple items at the root level.

    7.2. Inconsistent Numbering

        Valid but inconsistent (accepted without error):
            1. First item
            3. Second item (numbered as 3)
            1. Third item (numbered as 1)
        (inconsistent)

        Original markers preserved; tools can auto-correct if needed.

    7.3. Mixed Styles

        Valid but mixed (first item determines official style):
            1. First item (style: Numerical)
            a. Second item (different style but accepted)
            i. Third item (different style but accepted)
        (mixed-styles)

        List officially has Numerical style based on first item.

    7.4. Single Items in Nested Context

        **Exception**: Single items ARE allowed within nested containers:
        
        Valid nested single item:
            - Main task (multiple items required at this level)
            - Another task
                - Single subtask (allowed because it's nested)
        (nested-single)

        The outer level has multiple items (valid list), and the nested single item is allowed because it's within a container.

8. Implementation Notes

    Lists follow the standard implementation pattern defined in [common-processing.txxt] with the following element-specific requirements:

    8.1. List-Specific Parser Integration

        Beyond standard parser integration, lists require:
        - Sequence marker recognition and validation using patterns from [syntax.txxt]
        - Style determination from first item (first item determines entire list style)
        - Exact marker preservation for source reconstruction
        - Nesting level tracking for Content Container creation

    8.2. Style Processing Implementation

        List-specific style determination:
            
            Function to determine list style from first marker:
                fn determine_style(marker: &str) -> ListDecorationType {
                    // Parse marker to determine NumberingStyle and NumberingForm
                    // Store for entire list based on first item
                }
            :: rust

    8.3. Source Reconstruction Capabilities

        List-specific reconstruction features:
        - Exact marker preservation enables faithful source reconstruction
        - Style consistency analysis for validation tools
        - Automated renumbering tools integration
        - Format conversion utilities support

9. Relationship to Other Elements

    9.1. Container Integration

        List nesting through containers:
        - Flat lists: No containers needed
        - Nested lists: Create Content Container for nested content
        - Mixed content: Content Container can hold any blocks except sessions

    9.2. Inline Content

        List item content:
        - Supports all inline elements (bold, italic, code, math, references)
        - Cannot span multiple lines within single item
        - Rich content goes in nested Content Container

    9.3. Annotation Support

        Lists support annotations:
        - List-level annotations: Attached to entire list
        - Item-level annotations: Attached to specific items
        - Content annotations: Within nested content


:: note :: Lists in txxt are designed for flexibility and forgiveness. The "first item determines style" rule combined with exact marker preservation enables both strict technical documentation and flexible authoring workflows.