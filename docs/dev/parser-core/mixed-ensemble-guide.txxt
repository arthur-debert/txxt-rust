:: title :: Mixed Ensemble Implementation Guide
:: author :: Arthur Debert
:: pub-date :: 2025-01-12
:: status :: Implementation Guide

This guide covers implementing parser support for mixed ensembles - documents that combine multiple element types in realistic document structures. This is Phase 2 of the parser implementation plan.

1. Overview

    This guide covers:
    - Testing parser with documents containing multiple element types
    - Validating element interaction and nesting
    - Testing with realistic document structures
    - Ensuring parser handles element combinations correctly

    Key principle: Elements must work together in realistic document contexts.

2. Prerequisites

    Before starting mixed ensemble work, ensure:
    - All individual elements are implemented (see Single Element Simple Guide)
    - All element assertions are validated and working
    - Basic integration tests pass
    - You understand ensemble document structure

3. Ensemble Document Types

    3.1. Flat Session Documents

        Documents with multiple elements at the same indentation level:
        ```
        Title
        
        Paragraph content here.
        
        - List item 1
        - List item 2
        
        term :: definition content
        
        More paragraph content.
        ```

    3.2. Nested Session Documents

        Documents with hierarchical session structure:
        ```
        1. Main Section
        
            Paragraph in main section.
            
            - List in main section
            - Another list item
            
            2. Subsection
            
                Paragraph in subsection.
                
                term :: definition in subsection
        ```

    3.3. Complex Mixed Documents

        Documents with multiple element types and nesting levels:
        ```
        Introduction
        
        This is a paragraph with *formatting*.
        
        - First item
        - Second item
            - Nested item
            - Another nested item
        
        term :: This is a definition
        
        :: note :: This is an annotation
        
        Conclusion
        
            Final paragraph content.
        ```

4. Implementation Workflow

    4.1. Step 1: Load Ensemble Document

        Load a mixed ensemble document:
        ```rust
        use tests::corpora::TxxtCorpora;
        let corpus = TxxtCorpora::load_document("01-two-paragraphs")?;
        // or
        let corpus = TxxtCorpora::load_document("05")?; // Prefix match
        ```

        Available ensemble patterns:
        - `01-two-paragraphs` - Simple mixed content
        - `05-session-nested` - Nested session structure
        - `11-complex-mixed` - Complex mixed elements

    4.2. Step 2: Write Ensemble Test

        Create a test that validates the entire document structure:
        ```rust
        #[test]
        fn test_ensemble_<name>() {
            let corpus = TxxtCorpora::load_document("<name>").unwrap();
            let result = parse_document(&corpus.source_text);
            
            assert!(result.is_ok());
            let document = result.unwrap();
            
            // Validate document structure
            validate_document_structure(&document, &corpus);
        }
        ```

    4.3. Step 3: Implement Document Structure Validation

        Create validation functions for ensemble documents:
        ```rust
        fn validate_document_structure(document: &Document, corpus: &TxxtCorpora) {
            // Validate element counts
            let stats = document.element_type_stats();
            assert_eq!(stats.paragraph_count, expected_paragraphs);
            assert_eq!(stats.list_count, expected_lists);
            assert_eq!(stats.session_count, expected_sessions);
            
            // Validate element relationships
            validate_element_relationships(document);
            
            // Validate content preservation
            validate_content_preservation(document, corpus);
        }
        ```

    4.4. Step 4: Test Element Interactions

        Ensure elements work correctly when combined:
        ```rust
        #[test]
        fn test_element_interactions() {
            let corpus = TxxtCorpora::load_document("05-session-nested").unwrap();
            let document = parse_document(&corpus.source_text).unwrap();
            
            // Test session-paragraph interaction
            let sessions = document.find_by_type(ElementType::Session);
            for session in sessions {
                assert!(session.has_content());
                assert!(session.content_contains(ElementType::Paragraph));
            }
            
            // Test list-item interaction
            let lists = document.find_by_type(ElementType::List);
            for list in lists {
                assert!(list.item_count() > 0);
                for item in list.items() {
                    assert!(item.has_content());
                }
            }
        }
        ```

    4.5. Step 5: Test Nesting and Indentation

        Validate that nesting and indentation work correctly:
        ```rust
        #[test]
        fn test_nesting_and_indentation() {
            let corpus = TxxtCorpora::load_document("05-session-nested").unwrap();
            let document = parse_document(&corpus.source_text).unwrap();
            
            // Test session nesting
            let root_sessions = document.root_sessions();
            for session in root_sessions {
                if session.has_subsessions() {
                    for subsession in session.subsessions() {
                        assert!(subsession.indentation_level() > session.indentation_level());
                    }
                }
            }
            
            // Test list nesting
            let lists = document.find_by_type(ElementType::List);
            for list in lists {
                if list.has_nested_items() {
                    for nested_item in list.nested_items() {
                        assert!(nested_item.indentation_level() > list.indentation_level());
                    }
                }
            }
        }
        ```

    4.6. Step 6: Test Content Preservation

        Ensure content is preserved correctly across element boundaries:
        ```rust
        #[test]
        fn test_content_preservation() {
            let corpus = TxxtCorpora::load_document("01-two-paragraphs").unwrap();
            let document = parse_document(&corpus.source_text).unwrap();
            
            // Test that all text content is preserved
            let all_text = document.extract_all_text();
            assert!(all_text.contains("expected content"));
            
            // Test that formatting is preserved
            let formatted_text = document.extract_formatted_text();
            assert!(formatted_text.contains("*bold*"));
            assert!(formatted_text.contains("_italic_"));
        }
        ```

5. Ensemble-Specific Testing Patterns

    5.1. Progressive Complexity Testing

        Test with increasingly complex ensemble documents:
        ```rust
        #[test]
        fn test_progressive_ensemble_complexity() {
            let test_cases = vec![
                "01-two-paragraphs",      // Simple
                "03-session-flat",        // Sessions
                "05-session-nested",      // Nested sessions
                "07-mixed-elements",      // Multiple element types
                "11-complex-mixed",       // Complex mixed
            ];
            
            for case in test_cases {
                let corpus = TxxtCorpora::load_document(case).unwrap();
                let result = parse_document(&corpus.source_text);
                assert!(result.is_ok(), "Failed to parse ensemble: {}", case);
                
                let document = result.unwrap();
                validate_document_structure(&document, &corpus);
            }
        }
        ```

    5.2. Element Combination Testing

        Test specific element combinations:
        ```rust
        #[test]
        fn test_element_combinations() {
            // Test paragraph + list combination
            test_paragraph_list_combination();
            
            // Test session + paragraph + list combination
            test_session_paragraph_list_combination();
            
            // Test definition + annotation combination
            test_definition_annotation_combination();
        }
        ```

    5.3. Edge Case Testing

        Test edge cases in ensemble documents:
        ```rust
        #[test]
        fn test_ensemble_edge_cases() {
            // Test empty sections
            test_empty_sections();
            
            // Test single element sections
            test_single_element_sections();
            
            // Test deeply nested structures
            test_deep_nesting();
        }
        ```

6. Validation Strategies

    6.1. Document Structure Validation

        Validate the overall document structure:
        ```rust
        fn validate_document_structure(document: &Document, expected: &DocumentStructure) {
            // Validate root structure
            assert_eq!(document.root_type(), expected.root_type);
            
            // Validate element counts
            let stats = document.element_type_stats();
            assert_eq!(stats.paragraph_count, expected.paragraph_count);
            assert_eq!(stats.list_count, expected.list_count);
            assert_eq!(stats.session_count, expected.session_count);
            
            // Validate hierarchy
            validate_hierarchy(document, &expected.hierarchy);
        }
        ```

    6.2. Content Validation

        Validate that content is preserved correctly:
        ```rust
        fn validate_content_preservation(document: &Document, original_text: &str) {
            // Extract all text content
            let extracted_text = document.extract_all_text();
            
            // Check that key content is preserved
            for expected_content in expected_content_pieces {
                assert!(extracted_text.contains(expected_content));
            }
            
            // Check that formatting is preserved
            validate_formatting_preservation(document, original_text);
        }
        ```

    6.3. Relationship Validation

        Validate relationships between elements:
        ```rust
        fn validate_element_relationships(document: &Document) {
            // Validate parent-child relationships
            for element in document.all_elements() {
                if let Some(parent) = element.parent() {
                    assert!(parent.contains_child(element));
                }
            }
            
            // Validate sibling relationships
            for element in document.all_elements() {
                if let Some(siblings) = element.siblings() {
                    for sibling in siblings {
                        assert_eq!(sibling.parent(), element.parent());
                    }
                }
            }
        }
        ```

7. Common Issues and Solutions

    7.1. Element Boundary Issues

        Problem: Elements not properly separated
        Solution: Check token patterns and element recognition logic

    7.2. Nesting Issues

        Problem: Incorrect nesting levels
        Solution: Validate indentation handling and container creation

    7.3. Content Loss

        Problem: Content lost between elements
        Solution: Check content extraction and preservation logic

    7.4. Formatting Issues

        Problem: Formatting lost in mixed content
        Solution: Validate inline parsing in mixed contexts

8. Integration Testing

    8.1. Full Pipeline Testing

        Test the complete parsing pipeline:
        ```rust
        #[test]
        fn test_full_pipeline_ensemble() {
            let corpus = TxxtCorpora::load_document("11-complex-mixed").unwrap();
            
            // Test complete pipeline
            let tokens = tokenize(&corpus.source_text)?;
            let token_tree = TokenTreeBuilder::new().build_tree(tokens)?;
            let blocks = BlockParser::new().parse_blocks(token_tree)?;
            let ast = InlineParser::new().parse_inlines(blocks)?;
            let document = Assembler::new().assemble_document(ast)?;
            
            // Validate final result
            validate_document_structure(&document, &corpus);
        }
        ```

    8.2. Round-Trip Testing

        Test that parsing preserves content for re-parsing:
        ```rust
        #[test]
        fn test_round_trip_ensemble() {
            let corpus = TxxtCorpora::load_document("05-session-nested").unwrap();
            
            // Parse document
            let document = parse_document(&corpus.source_text)?;
            
            // Convert back to text
            let reconstructed = document.to_txxt_text();
            
            // Parse again
            let document2 = parse_document(&reconstructed)?;
            
            // Should be equivalent
            assert_eq!(document.element_type_stats(), document2.element_type_stats());
        }
        ```

9. Success Criteria

    An ensemble implementation is complete when:
    - [ ] All ensemble test cases pass
    - [ ] Element interactions work correctly
    - [ ] Nesting and indentation are handled properly
    - [ ] Content is preserved across element boundaries
    - [ ] Full pipeline integration tests pass
    - [ ] Round-trip tests pass

10. Next Steps

    After completing mixed ensemble implementation:
    1. Move to complex element cases (see Complex Element Guide)
    2. Implement remaining element types
    3. Add performance testing
    4. Prepare for production use

:: note :: This guide focuses on mixed ensemble testing. For single elements or complex cases, see the respective guides.
