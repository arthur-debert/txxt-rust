//! Parser Integration Tests using TxxtCorpora
//!
//! This module demonstrates how to use the `TxxtCorpora` utility for spec-driven testing.
//!
//! # For Parser Developers
//!
//! When implementing parser components, use TxxtCorpora to load test cases directly
//! from the specification documents. This ensures your implementation matches the
//! authoritative specification.
//!
//! ## Basic Usage:
//! ```rust
//! let corpus = TxxtCorpora::load("txxt.core.spec.paragraph.valid.simple")?;
//! let ast = your_parser::parse(&corpus.source_text)?;
//! insta::assert_yaml_snapshot!(ast);
//! ```
//!
//! ## With Processing Stages:
//! ```rust
//! let corpus = TxxtCorpora::load_with_processing(
//!     "txxt.core.spec.paragraph.valid.simple",
//!     ProcessingStage::ScannerTokens
//! )?;
//! let tokens = corpus.tokens().unwrap();
//! // Test your tokenizer against expected tokens
//! ```
//!
//! ## Error Cases:
//! ```rust
//! let corpus = TxxtCorpora::load("txxt.core.spec.list.error.singleItem")?;
//! assert!(corpus.is_error_case());
//! let result = your_parser::parse(&corpus.source_text);
//! assert!(result.is_err());
//! ```
//!
//! See `tests/README.md` for complete documentation.

mod corpora {
    include!("../infrastructure/corpora.rs");
}

use corpora::{ProcessingStage, TxxtCorpora};

#[test]
fn test_paragraph_simple_valid() {
    let corpus = TxxtCorpora::load("txxt.core.spec.paragraph.valid.simple")
        .expect("Failed to load simple paragraph corpus");

    assert_eq!(corpus.name, "txxt.core.spec.paragraph.valid.simple");
    assert!(!corpus.source_text.is_empty());
    assert!(corpus.parameters.is_empty());

    // Verify the extracted content matches what we expect
    let expected_text = "This is a basic paragraph containing plain text. It flows naturally and can span multiple lines within the same paragraph block.";
    assert_eq!(corpus.source_text.trim(), expected_text);
}

#[test]
fn test_paragraph_multiline_valid() {
    let corpus = TxxtCorpora::load("txxt.core.spec.paragraph.valid.multiline")
        .expect("Failed to load multiline paragraph corpus");

    assert_eq!(corpus.name, "txxt.core.spec.paragraph.valid.multiline");
    assert!(!corpus.source_text.is_empty());
    assert!(corpus.parameters.is_empty());

    // Verify the extracted content matches what we expect (multiline)
    let expected_lines = [
        "This paragraph begins on one line",
        "and continues on the next line.",
        "All lines at the same indentation level",
        "belong to the same paragraph.",
    ];
    let expected_text = expected_lines.join("\n");
    assert_eq!(corpus.source_text.trim(), expected_text);
}

#[test]
fn test_load_all_corpora() {
    let corpora = TxxtCorpora::load_all().expect("Failed to load all corpora");

    // Should find at least the two paragraph test cases we added
    assert!(corpora.len() >= 2);

    let paragraph_corpora: Vec<_> = corpora
        .iter()
        .filter(|c| c.name.starts_with("txxt.core.spec.paragraph"))
        .collect();

    assert!(paragraph_corpora.len() >= 2);

    // Verify we can find specific test cases
    let simple_found = paragraph_corpora
        .iter()
        .any(|c| c.name == "txxt.core.spec.paragraph.valid.simple");
    let multiline_found = paragraph_corpora
        .iter()
        .any(|c| c.name == "txxt.core.spec.paragraph.valid.multiline");

    assert!(simple_found, "Simple paragraph corpus not found");
    assert!(multiline_found, "Multiline paragraph corpus not found");
}

#[test]
fn test_corpus_not_found() {
    let result = TxxtCorpora::load("txxt.core.spec.nonexistent.test");
    assert!(result.is_err());

    if let Err(corpora::CorpusError::CorpusNotFound(name)) = result {
        assert_eq!(name, "txxt.core.spec.nonexistent.test");
    } else {
        panic!("Expected CorpusNotFound error");
    }
}

#[test]
fn test_paragraph_simple_with_tokenization() {
    let corpus = TxxtCorpora::load_with_processing(
        "txxt.core.spec.paragraph.valid.simple",
        ProcessingStage::ScannerTokens,
    )
    .expect("Failed to load simple paragraph corpus with tokenization");

    assert_eq!(corpus.name, "txxt.core.spec.paragraph.valid.simple");
    assert_eq!(corpus.processing_stage, ProcessingStage::ScannerTokens);

    // Verify tokenized data is available
    let tokens = corpus.tokens().expect("Tokens should be available");
    assert!(!tokens.is_empty());

    // Should contain words from the paragraph
    assert!(tokens.contains(&"This".to_string()));
    assert!(tokens.contains(&"paragraph".to_string()));
}

#[test]
fn test_paragraph_with_ast_processing() {
    let corpus = TxxtCorpora::load_with_processing(
        "txxt.core.spec.paragraph.valid.simple",
        ProcessingStage::AstFull,
    )
    .expect("Failed to load simple paragraph corpus with AST processing");

    assert_eq!(corpus.processing_stage, ProcessingStage::AstFull);

    // Verify AST data is available (placeholder for now)
    let ast = corpus.ast().expect("AST should be available");
    assert!(ast.starts_with("ParsedAST("));
}

#[test]
fn test_processing_stage_comparison() {
    // Test that we can load the same corpus with different processing stages
    let raw_corpus = TxxtCorpora::load_with_processing(
        "txxt.core.spec.paragraph.valid.simple",
        ProcessingStage::ScannerTokens,
    )
    .expect("Failed to load raw corpus");

    let token_corpus = TxxtCorpora::load_with_processing(
        "txxt.core.spec.paragraph.valid.simple",
        ProcessingStage::ScannerTokens,
    )
    .expect("Failed to load tokenized corpus");

    // Same source text and name
    assert_eq!(raw_corpus.name, token_corpus.name);
    assert_eq!(raw_corpus.source_text, token_corpus.source_text);

    // Different processing stages
    assert_eq!(raw_corpus.processing_stage, ProcessingStage::ScannerTokens);
    assert_eq!(token_corpus.processing_stage, ProcessingStage::ScannerTokens);

    // Raw corpus has no tokens, tokenized corpus has tokens
    assert!(raw_corpus.tokens().is_none());
    assert!(token_corpus.tokens().is_some());
}

// TODO: Add actual parser integration tests once the parser is implemented
//
// #[test]
// fn test_parse_simple_paragraph() {
//     let corpus = TxxtCorpora::load("txxt.core.spec.paragraph.valid.simple")
//         .expect("Failed to load simple paragraph corpus");
//
//     let ast = crate::parser::parse(&corpus.source_text)
//         .expect("Failed to parse simple paragraph");
//
//     assert_yaml_snapshot!(ast);
// }
