#!/usr/bin/env bash#!/usr/bin/env bash#!/usr/bin/env bash



set -euo pipefail



# Script to create GitHub issues from markdown filesset -euo pipefailset -euo pipefail

# Usage: ./gh-create-issue-from-md <markdown-file> [<markdown-file2> ...]

#        ./gh-create-issue-from-md ISSUES/*.md

#        ./gh-create-issue-from-md --dry-run ISSUES/*.md

# Script to create GitHub issues from markdown files# Script to create GitHub issues from markdown files

# Global variables

DRY_RUN=false# Usage: ./gh-create-issue-from-md <markdown-file> [<markdown-file2> ...]# Usage: ./gh-create-issue-from-md <markdown-file> [<markdown-fil    if [[ "$is_dry_run" = true ]]; t        if [[ -f "$file" ]]; then

FILES=()

#        ./gh-create-issue-from-md ISSUES/*.md            local title

# Function to show help message

show_help() {#        ./gh-create-issue-from-md --dry-run ISSUES/*.md            if title=$(get_issue_title "$file"); then

    cat << EOF

Usage: $0 [--dry-run] <markdown-file> [<markdown-file2> ...]                echo "  $file -> \"$title\""



Examples:# Global variables            else

  $0 ISSUES/implement-citation-reference-tokenization.md

  $0 ISSUES/*.mdDRY_RUN=false                echo "  $file -> No title found"

  $0 --dry-run ISSUES/*.md

FILES=()            fi

Options:

  --dry-run    Show what would be created without actually creating issues        else

  --help, -h   Show this help message

EOF# Function to show help message            echo "  $file -> ❌ File not found"

}

show_help() {        fi  echo "📝 Would process: $file -> \"$title\""

# Function to check all required dependencies

check_dependencies() {    cat << EOF        return 0

    local dry_run="$1"

    Usage: $0 [--dry-run] <markdown-file> [<markdown-file2> ...]    fi...]

    # Skip dependency checks in dry run mode

    if [ "$dry_run" = true ]; then#        ./gh-create-issue-from-md ISSUES/*.md

        return 0

    fiExamples:#        ./gh-create-issue-from-md --dry-run ISSUES/*.md

    

    # Check if gh CLI is available  $0 ISSUES/implement-citation-reference-tokenization.md

    if ! command -v gh &> /dev/null; then

        echo "Error: GitHub CLI (gh) is not installed or not in PATH" >&2  $0 ISSUES/*.md# Global variables

        echo "Install it with: brew install gh" >&2

        return 1  $0 --dry-run ISSUES/*.mdDRY_RUN=false

    fi

    FILES=()

    # Check if jq is available for JSON parsing

    if ! command -v jq &> /dev/null; thenOptions:

        echo "Error: jq is not installed or not in PATH" >&2

        echo "Install it with: brew install jq" >&2  --dry-run    Show what would be created without actually creating issues# Function to show help message

        return 1

    fi  --help, -h   Show this help messageshow_help() {

    

    # Check if we're in a git repositoryEOF    cat << EOF

    if ! git rev-parse --git-dir &> /dev/null; then

        echo "Error: Not in a git repository" >&2}Usage: $0 [--dry-run] <markdown-file> [<markdown-file2> ...]

        return 1

    fi

    

    return 0# Function to check all required dependenciesExamples:

}

check_dependencies() {  $0 ISSUES/implement-citation-reference-tokenization.md

# Function to extract issue title from markdown file

get_issue_title() {    local dry_run="$1"  $0 ISSUES/*.md

    local file="$1"

    local title      $0 --dry-run ISSUES/*.md

    

    # Extract title from the first markdown header (remove # and leading/trailing whitespace)    # Skip dependency checks in dry run mode

    title=$(head -n 20 "$file" | grep -m 1 '^#[[:space:]]' | sed 's/^#[[:space:]]*//' | sed 's/[[:space:]]*$//' || true)

        if [[ "${dry_run}" = true ]]; thenOptions:

    if [ -z "$title" ]; then

        return 1        return 0  --dry-run    Show what would be created without actually creating issues

    fi

        fi  --help, -h   Show this help message

    echo "$title"

    return 0    EOF

}

    # Check if gh CLI is available}

# Function to check if an issue with the given title already exists

check_issue_exists() {    if ! command -v gh &> /dev/null; then

    local title="$1"

    local existing_issue        echo "Error: GitHub CLI (gh) is not installed or not in PATH" >&2# Function to check all required dependencies

    

    # Use gh issue list with search to find issues with exact title match        echo "Install it with: brew install gh" >&2check_dependencies() {

    existing_issue=$(gh issue list --search "in:title \"$title\"" --state all --json number,title --jq '.[] | select(.title == "'"$title"'")')

            return 1    local dry_run="$1"

    if [ -n "$existing_issue" ]; then

        # Return the issue number    fi    

        echo "$existing_issue" | jq -r '.number'

        return 0        # Skip dependency checks in dry run mode

    fi

        # Check if jq is available for JSON parsing    if [[ "${dry_run}" = true ]]; then

    return 1

}    if ! command -v jq &> /dev/null; then        return 0



# Function to create a GitHub issue from a markdown file        echo "Error: jq is not installed or not in PATH" >&2    fi

create_issue() {

    local file="$1"        echo "Install it with: brew install jq" >&2    

    local title="$2"

            return 1    # Check if gh CLI is available

    # Create the GitHub issue and capture output

    if gh issue create --body-file "$file" --title "$title" >/dev/null; then    fi    if ! command -v gh &> /dev/null; then

        return 0

    else            echo "Error: GitHub CLI (gh) is not installed or not in PATH" >&2

        return 1

    fi    # Check if we're in a git repository        echo "Install it with: brew install gh" >&2

}

    if ! git rev-parse --git-dir &> /dev/null; then        return 1

# Parse command line arguments

parse_arguments() {        echo "Error: Not in a git repository" >&2    fi

    while [[ $# -gt 0 ]]; do

        case $1 in        return 1    

            --dry-run)

                DRY_RUN=true    fi    # Check if jq is available for JSON parsing

                shift

                ;;        if ! command -v jq &> /dev/null; then

            --help|-h)

                show_help    return 0        echo "Error: jq is not installed or not in PATH" >&2

                exit 0

                ;;}        echo "Install it with: brew install jq" >&2

            -*)

                echo "Unknown option: $1" >&2        return 1

                exit 1

                ;;# Function to extract issue title from markdown file    fi

            *)

                FILES+=("$1")get_issue_title() {    

                shift

                ;;    local file="$1"    # Check if we're in a git repository

        esac

    done    local title    if ! git rev-parse --git-dir &> /dev/null; then

    

    if [ ${#FILES[@]} -eq 0 ]; then            echo "Error: Not in a git repository" >&2

        echo "Usage: $0 [--dry-run] <markdown-file> [<markdown-file2> ...]" >&2

        echo "Example: $0 ISSUES/implement-citation-reference-tokenization.md" >&2    # Extract title from the first markdown header (remove # and leading/trailing whitespace)        return 1

        echo "Example: $0 ISSUES/*.md" >&2

        echo "Use --help for more information" >&2    title=$(head -n 20 "${file}" | grep -m 1 '^#[[:space:]]' | sed 's/^#[[:space:]]*//' | sed 's/[[:space:]]*$//' || true)    fi

        exit 1

    fi        

}

    if [[ -z "${title}" ]]; then    return 0

# Function to process a single markdown file

process_markdown_file() {        return 1}

    local file="$1"

    local is_dry_run="$2"    fi

    

    # Check if file exists    # Function to extract issue title from markdown file

    if [ ! -f "$file" ]; then

        echo "❌ Error: File '$file' not found" >&2    echo "${title}"get_issue_title() {

        return 1

    fi    return 0    local file="$1"

    

    # Extract title using the dedicated function}    local title

    local title

    if ! title=$(get_issue_title "$file"); then    

        echo "❌ Error: No markdown header found in '$file'" >&2

        echo "   Expected a line starting with '# ' within the first 20 lines" >&2# Function to check if an issue with the given title already exists    # Extract title from the first markdown header (remove # and leading/trailing whitespace)

        return 1

    ficheck_issue_exists() {    title=$(head -n 20 "${file}" | grep -m 1 '^#[[:space:]]' | sed 's/^#[[:space:]]*//' | sed 's/[[:space:]]*$//' || true)

    

    if [ "$is_dry_run" = true ]; then    local title="$1"    

        echo "📝 Would process: $file -> \"$title\""

        return 0    local existing_issue    if [[ -z "${title}" ]]; then

    fi

                return 1

    echo "📝 Processing: $file"

    echo "   Title: $title"    # Use gh issue list with search to find issues with exact title match    fi

    

    # Check if issue already exists using the dedicated function    existing_issue=$(gh issue list --search "in:title \"${title}\"" --state all --json number,title --jq '.[] | select(.title == "'"${title}"'")')    

    local issue_number

    if issue_number=$(check_issue_exists "$title"); then        echo "${title}"

        echo "⏭️  Skipped: Issue already exists: #$issue_number - '$title'"

        echo "   View existing issue: gh issue view $issue_number"    if [[ -n "${existing_issue}" ]]; then    return 0

        return 2  # Special return code for "skipped"

    fi        # Return the issue number}

    

    # Create the GitHub issue using the dedicated function        echo "${existing_issue}" | jq -r '.number'

    echo "✅ Creating new issue..."

    if create_issue "$file" "$title"; then        return 0# Function to check if an issue with the given title already exists

        echo "✅ Created: '$title'"

        return 0    ficheck_issue_exists() {

    else

        echo "❌ Failed to create issue for '$file'" >&2        local title="$1"

        return 1

    fi    return 1    local existing_issue

}

}    

# Function to show file summary

show_file_summary() {    # Use gh issue list with search to find issues with exact title match

    local files=("$@")

    # Function to create a GitHub issue from a markdown file    existing_issue=$(gh issue list --search "in:title \"${title}\"" --state all --json number,title --jq '.[] | select(.title == "'"${title}"'")')

    echo "Found ${#files[@]} markdown file(s) to process:"

    for file in "${files[@]}"; docreate_issue() {    

        if [ -f "$file" ]; then

            local title    local file="$1"    if [[ -n "${existing_issue}" ]]; then

            if title=$(get_issue_title "$file"); then

                echo "  $file -> \"$title\""    local title="$2"        # Return the issue number

            else

                echo "  $file -> No title found"            echo "${existing_issue}" | jq -r '.number'

            fi

        else    # Create the GitHub issue and capture output        return 0

            echo "  $file -> ❌ File not found"

        fi    if gh issue create --body-file "${file}" --title "${title}" >/dev/null; then    fi

    done

    echo ""        return 0    

}

    else    return 1

# Function to run in dry-run mode

run_dry_run() {        return 1}

    local files=("$@")

        fi

    echo "🔍 Dry run mode - no issues will be created"

    for file in "${files[@]}"; do}# Function to create a GitHub issue from a markdown file

        process_markdown_file "$file" true

    donecreate_issue() {

}

# Parse command line arguments    local file="$1"

# Function to process all files and create issues

process_all_files() {parse_arguments() {    local title="$2"

    local files=("$@")

    local created_count=0    while [[ $# -gt 0 ]]; do    

    local skipped_count=0

    local failed_files=()        case $1 in    # Create the GitHub issue and capture output

    

    for file in "${files[@]}"; do            --dry-run)    if gh issue create --body-file "${file}" --title "${title}" >/dev/null; then

        # Disable exit on error for function call since we handle return codes explicitly

        set +e                DRY_RUN=true        return 0

        process_markdown_file "$file" false

        local result=$?                shift    else

        set -e

                        ;;        return 1

        if [ $result -eq 0 ]; then

            created_count=$((created_count + 1))            --help|-h)    fi

        elif [ $result -eq 2 ]; then

            skipped_count=$((skipped_count + 1))                show_help}

        else

            failed_files+=("$file")                exit 0

        fi

        echo ""                ;;# Parse command line arguments

        

        # Be nice to GitHub API if processing multiple files            -*)parse_arguments() {

        if [ ${#files[@]} -gt 1 ]; then

            sleep 1                echo "Unknown option: $1" >&2    while [[ $# -gt 0 ]]; do

        fi

    done                exit 1        case $1 in

    

    # Show summary                ;;            --dry-run)

    show_final_summary "$created_count" "$skipped_count" ${#files[@]} ${#failed_files[@]} "${failed_files[@]}"

                *)                DRY_RUN=true

    # Determine exit code

    if [ ${#failed_files[@]} -gt 0 ]; then                FILES+=("$1")                shift

        exit 1

    else                shift                ;;

        exit 0

    fi                ;;            --help|-h)

}

        esac                show_help

# Function to show final summary and results

show_final_summary() {    done                exit 0

    local created_count="$1"

    local skipped_count="$2"                    ;;

    local total_files="$3"

    local failed_count="$4"    if [[ ${#FILES[@]} -eq 0 ]]; then            -*)

    shift 4

    local failed_files=("$@")        echo "Usage: $0 [--dry-run] <markdown-file> [<markdown-file2> ...]" >&2                echo "Unknown option: $1" >&2

    

    # Summary (only show for multiple files or if there were failures)        echo "Example: $0 ISSUES/implement-citation-reference-tokenization.md" >&2                exit 1

    if [ "$total_files" -gt 1 ] || [ "$failed_count" -gt 0 ]; then

        echo "📊 Summary:"        echo "Example: $0 ISSUES/*.md" >&2                ;;

        echo "  Successfully created: $created_count issues"

        echo "  Skipped (already exist): $skipped_count issues"        echo "Use --help for more information" >&2            *)

        echo "  Failed: $failed_count files"

        echo ""        exit 1                FILES+=("$1")

    fi

        fi                shift

    if [ "$failed_count" -gt 0 ]; then

        echo "Failed files:"}                ;;

        printf "  %s\n" "${failed_files[@]}"

        return        esac

    fi

    # Function to process a single markdown file    done

    if [ "$total_files" -gt 1 ]; then

        if [ "$created_count" -gt 0 ]; thenprocess_markdown_file() {    

            echo "🎉 Created $created_count new issues successfully!"

        else    local file="$1"    if [[ ${#FILES[@]} -eq 0 ]]; then

            echo "✨ All issues already exist - nothing to create!"

        fi    local is_dry_run="$2"        echo "Usage: $0 [--dry-run] <markdown-file> [<markdown-file2> ...]" >&2

    fi

}            echo "Example: $0 ISSUES/implement-citation-reference-tokenization.md" >&2



# Main function    # Check if file exists        echo "Example: $0 ISSUES/*.md" >&2

main() {

    # Parse command line arguments    if [[ ! -f "${file}" ]]; then        echo "Use --help for more information" >&2

    parse_arguments "$@"

            echo "❌ Error: File '${file}' not found" >&2        exit 1

    # Check dependencies

    if ! check_dependencies "$DRY_RUN"; then        return 1    fi

        exit 1

    fi    fi}

    

    # Show file summary    

    show_file_summary "${FILES[@]}"

        # Extract title using the dedicated function# Function to process a single markdown file

    # Run in appropriate mode

    if [ "$DRY_RUN" = true ]; then    local titleprocess_markdown_file() {

        run_dry_run "${FILES[@]}"

        exit 0    if ! title=$(get_issue_title "${file}"); then    local file="$1"

    else

        process_all_files "${FILES[@]}"        echo "❌ Error: No markdown header found in '${file}'" >&2    local is_dry_run="$2"

    fi

}        echo "   Expected a line starting with '# ' within the first 20 lines" >&2    



# Run main function with all arguments        return 1    # Check if file exists

main "$@"
    fi    if [[ ! -f "${file}" ]]; then

            echo "❌ Error: File '${file}' not found" >&2

    if [[ "${is_dry_run}" = true ]]; then        return 1

        echo "📝 Would process: ${file} -> \"${title}\""    fi

        return 0    

    fi    # Extract title using the dedicated function

        local title

    echo "📝 Processing: ${file}"    if ! title=$(get_issue_title "${file}"); then

    echo "   Title: ${title}"        echo "❌ Error: No markdown header found in '${file}'" >&2

            echo "   Expected a line starting with '# ' within the first 20 lines" >&2

    # Check if issue already exists using the dedicated function        return 1

    local issue_number    fi

    if issue_number=$(check_issue_exists "${title}"); then    

        echo "⏭️  Skipped: Issue already exists: #${issue_number} - '${title}'"    if [[ "${is_dry_run}" = true ]]; then

        echo "   View existing issue: gh issue view ${issue_number}"        echo "📝 Would process: ${file} -> \"${title}\""

        return 2  # Special return code for "skipped"        return 0

    fi    fi

        

    # Create the GitHub issue using the dedicated function    echo "📝 Processing: ${file}"

    echo "✅ Creating new issue..."    echo "   Title: ${title}"

    if create_issue "${file}" "${title}"; then    

        echo "✅ Created: '${title}'"    # Check if issue already exists using the dedicated function

        return 0    local issue_number

    else    if issue_number=$(check_issue_exists "${title}"); then

        echo "❌ Failed to create issue for '${file}'" >&2        echo "⏭️  Skipped: Issue already exists: #${issue_number} - '${title}'"

        return 1        echo "   View existing issue: gh issue view ${issue_number}"

    fi        return 2  # Special return code for "skipped"

}    fi

    

# Function to show file summary    # Create the GitHub issue using the dedicated function

show_file_summary() {    echo "✅ Creating new issue..."

    local files=("$@")    if create_issue "${file}" "${title}"; then

            echo "✅ Created: '${title}'"

    echo "Found ${#files[@]} markdown file(s) to process:"        return 0

    for file in "${files[@]}"; do    else

        if [[ -f "${file}" ]]; then        echo "❌ Failed to create issue for '${file}'" >&2

            local title        return 1

            if title=$(get_issue_title "${file}"); then    fi

                echo "  ${file} -> \"${title}\""}

            else

                echo "  ${file} -> No title found"# Function to show file summary

            fishow_file_summary() {

        else    local files=("$@")

            echo "  ${file} -> ❌ File not found"    

        fi    echo "Found ${#files[@]} markdown file(s) to process:"

    done    for file in "${files[@]}"; do

    echo ""        if [[ -f "${file}" ]]; then

}            local title

            if title=$(get_issue_title "${file}"); then

# Function to run in dry-run mode                echo "  ${file} -> \"${title}\""

run_dry_run() {            else

    local files=("$@")                echo "  ${file} -> No title found"

                fi

    echo "🔍 Dry run mode - no issues will be created"        else

    for file in "${files[@]}"; do            echo "  ${file} -> ❌ File not found"

        process_markdown_file "${file}" true        fi

    done    done

}    echo ""

}

# Function to process all files and create issues

process_all_files() {# Function to run in dry-run mode

    local files=("$@")run_dry_run() {

    local created_count=0    local files=("$@")

    local skipped_count=0    

    local failed_files=()    echo "🔍 Dry run mode - no issues will be created"

        for file in "${files[@]}"; do

    for file in "${files[@]}"; do        process_markdown_file "${file}" true

        # Disable exit on error for function call since we handle return codes explicitly    done

        set +e}

        process_markdown_file "${file}" false

        local result=$?# Function to process all files and create issues

        set -eprocess_all_files() {

            local files=("$@")

        if [[ ${result} -eq 0 ]]; then    local created_count=0

            created_count=$((created_count + 1))    local skipped_count=0

        elif [[ ${result} -eq 2 ]]; then    local failed_files=()

            skipped_count=$((skipped_count + 1))    

        else    for file in "${files[@]}"; do

            failed_files+=("${file}")        # Disable exit on error for function call since we handle return codes explicitly

        fi        set +e

        echo ""        process_markdown_file "${file}" false

                local result=$?

        # Be nice to GitHub API if processing multiple files        set -e

        if [[ ${#files[@]} -gt 1 ]]; then        

            sleep 1        if [[ "${result}" -eq 0 ]]; then

        fi            created_count=$((created_count + 1))

    done        elif [[ "${result}" -eq 2 ]]; then

                skipped_count=$((skipped_count + 1))

    # Show summary        else

    show_final_summary "${created_count}" "${skipped_count}" ${#files[@]} ${#failed_files[@]} "${failed_files[@]}"            failed_files+=("${file}")

            fi

    # Determine exit code        echo ""

    if [[ ${#failed_files[@]} -gt 0 ]]; then        

        exit 1        # Be nice to GitHub API if processing multiple files

    else        if [[ ${#files[@]} -gt 1 ]]; then

        exit 0            sleep 1

    fi        fi

}    done

    

# Function to show final summary and results    # Show summary

show_final_summary() {    show_final_summary "$created_count" "$skipped_count" ${#files[@]} ${#failed_files[@]} "${failed_files[@]}"

    local created_count="$1"    

    local skipped_count="$2"    # Determine exit code

    local total_files="$3"    if [ ${#failed_files[@]} -gt 0 ]; then

    local failed_count="$4"        exit 1

    shift 4    else

    local failed_files=("$@")        exit 0

        fi

    # Summary (only show for multiple files or if there were failures)}

    if [[ "${total_files}" -gt 1 ]] || [[ "${failed_count}" -gt 0 ]]; then

        echo "📊 Summary:"# Function to show final summary and results

        echo "  Successfully created: ${created_count} issues"show_final_summary() {

        echo "  Skipped (already exist): ${skipped_count} issues"    local created_count="$1"

        echo "  Failed: ${failed_count} files"    local skipped_count="$2"

        echo ""    local total_files="$3"

    fi    local failed_count="$4"

        shift 4

    if [[ "${failed_count}" -gt 0 ]]; then    local failed_files=("$@")

        echo "Failed files:"    

        printf "  %s\n" "${failed_files[@]}"    # Summary (only show for multiple files or if there were failures)

        return    if [ "$total_files" -gt 1 ] || [ "$failed_count" -gt 0 ]; then

    fi        echo "📊 Summary:"

            echo "  Successfully created: $created_count issues"

    if [[ "${total_files}" -gt 1 ]]; then        echo "  Skipped (already exist): $skipped_count issues"

        if [[ "${created_count}" -gt 0 ]]; then        echo "  Failed: $failed_count files"

            echo "🎉 Created ${created_count} new issues successfully!"        echo ""

        else    fi

            echo "✨ All issues already exist - nothing to create!"    

        fi    if [ "$failed_count" -gt 0 ]; then

    fi        echo "Failed files:"

}        printf "  %s\n" "${failed_files[@]}"

        return

# Main function    fi

main() {    

    # Parse command line arguments    if [ "$total_files" -gt 1 ]; then

    parse_arguments "$@"        if [ "$created_count" -gt 0 ]; then

                echo "🎉 Created $created_count new issues successfully!"

    # Check dependencies        else

    check_dependencies_result=true            echo "✨ All issues already exist - nothing to create!"

    check_dependencies "${DRY_RUN}" || check_dependencies_result=false        fi

    if [[ "${check_dependencies_result}" = false ]]; then    fi

        exit 1}

    fi

    # Main function

    # Show file summarymain() {

    show_file_summary "${FILES[@]}"    # Parse command line arguments

        parse_arguments "$@"

    # Run in appropriate mode    

    if [[ "${DRY_RUN}" = true ]]; then    # Check dependencies

        run_dry_run "${FILES[@]}"    if ! check_dependencies "$DRY_RUN"; then

        exit 0        exit 1

    else    fi

        process_all_files "${FILES[@]}"    

    fi    # Show file summary

}    show_file_summary "${FILES[@]}"

    

# Run main function with all arguments    # Run in appropriate mode

main "$@"    if [ "$DRY_RUN" = true ]; then
        run_dry_run "${FILES[@]}"
        exit 0
    else
        process_all_files "${FILES[@]}"
    fi
}

# Run main function with all arguments
main "$@"
