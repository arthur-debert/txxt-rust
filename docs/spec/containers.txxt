:: title :: Proposal: Uniform Content Representation in the AST
:: author :: Gemini & adebert
:: status :: Proposed

This proposal introduces `ContentContainer` and `TextLine` nodes to create a uniform, predictable, and more powerful AST structure for all multi-line content.

1. The Core Problem: An Inconsistent AST

	The current AST is inconsistent. It uses a mix of different strategies for representing content, which forces the parser into complex, special-case logic that is prone to edge-case bugs.

	-   Paragraphs lose the author's original line structure by joining lines into a single string.
	-   ListItems have a "bag of nodes" for children, mixing inline content, paragraphs, and other blocks at different conceptual indentation levels.
	-   Definitions have two separate places for content (`term` and `content`), creating an irregular structure.
	-   Annotations discard the block structure of their multi-line content entirely.

	This inconsistency is the root cause of many parsing challenges. The `IndentationTreeBuilder` pass creates a simple, uniform tree based on structure, but the `AstBuilder` pass must immediately break that uniformity to shoehorn the structure into these inconsistent AST nodes. This is where complexity and bugs arise.

2. The Solution: Uniform Containers and Lines

	We will solve this by introducing two new node types that make the AST's structure as regular and predictable as the parser's internal representation.

2.1. The `TextLine` Node

	A `TextLine` node represents a single, unbroken line of text content. This elevates the most fundamental unit of `txxt`—the line—to a first-class citizen in the AST.

		Paragraph
		├── TextLine("First line of paragraph.")
		├── TextLine("Second line continues here.")  
		└── TextLine("Final line of the paragraph.")

	Benefits:
	-   Preserves Semantic Line Breaks: The AST now faithfully represents the author's intentional line structure.
	-   Enables Line-Based Tooling: Features like error reporting, code folding, and LSP diagnostics can now map directly to specific lines in the AST.
	-   Eliminates Information Loss: We stop the destructive `join -> split` cycle that loses critical position information.

2.2. The `ContentContainer` Node

	A `ContentContainer` is a simple, universal node that explicitly represents a block of indented content. The rule is simple: if a block type has indented content, that content lives inside a `ContentContainer`.

		ContentContainer
		├── Paragraph
		│   ├── TextLine("First paragraph")
		│   └── TextLine("continues here.")
		├── List
		└── Verbatim

	Benefits:
	-   Uniform Parsing: The logic for parsing the children of a `ListItem`, a `Definition`, and a multi-line `Annotation` becomes -identical-. The parser simply recurses into the `ContentContainer`.  -   Eliminates Special Casing: The ambiguity of "what does it mean to be a child of a `ListItem`?" disappears. This dramatically simplifies the `AstBuilder`. 
	-   Clear Structure: The AST now has a predictable, easy-to-navigate structure for all nested content.

3. The New, Uniform AST Structure

	This is how the core multi-line elements will be represented:

	List Items: We acknowledge that `ListItems` are special, as their first line of text is at the same indentation level as the marker.
	ListItem
	├── marker: "-"
	└── children:
		├── Paragraph                    // First line's content (+0 indent)
		│   └── TextLine("Item text.")
		└── ContentContainer             // Additional, indented content (+1 indent)
			├── Paragraph
			└── List

	Definitions: The `term` becomes a list of inline nodes, and all definition content resides in a `ContentContainer`.
		Definition
		├── term: [Text("Parser")]
		└── children:
			└── ContentContainer             // All content (+1 indent)
				└── Paragraph
					├── TextLine("A program that analyzes text")
					└── TextLine("according to formal grammar rules.")

	Annotations: Both single-line and multi-line annotations now have a uniform structure.
		Annotation
		├── label: "note"
		└── children:
			└── ContentContainer             // All content (+1 indent)
				└── Paragraph
					└── TextLine("This is important.")

4. Conclusion

	By making the implicit concepts of "lines" and "indented content" explicit parts of the AST, we create a more regular and powerful structure. This change:

	-   Fixes the Root Cause of Edge Cases: It eliminates the AST inconsistencies that create parsing complexity.
	-   Dramatically Simplifies the Parser: It allows us to remove a significant amount of special-case logic from the `AstBuilder`.
	-   Unlocks Better Tooling: It provides the necessary structure for advanced features like code folding and precise diagnostics.

	This is a high-leverage architectural improvement that aligns the final AST with the clean, multi-pass design of the new parser, paving the way for a more robust and feature-rich future.

5. Future

	And later on , we could extend this idea to fix the other wart in parssing, sessions. 

	Session containers can't be the same as ContentContainer as you don't want a ListItem that has a Session in it.
	But we could simply define SessionContainer to be a super set of ContentContainer that can have session as children
	
	Currently the sesstion title is an atrribute of session, and this causes the wart: session have an attribute indendet at 0, and it's children indented at +1

	Under this design we would unify things: 
	Session
	└── children:
		├── Paragraph                    // This is not the session title , just like a lite item "title" is it's first paragraph
		│   └── TextLine("Item text.")
		└── SessionContainer

	This would bring complete uniformity, a container always demands +1 indentation. And things like code folding would be trivial , just toggle the Container inside the level you're folding.
			
		