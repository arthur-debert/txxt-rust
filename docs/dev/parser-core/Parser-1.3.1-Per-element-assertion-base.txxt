Parser 1.3.1 Custom AST Assertion System Design

Design specification for ergonomic AST validation using builder-pattern configuration objects.

1. Purpose

    Create ergonomic, reusable assertion helpers using a single method per element with optional configuration:
    - Easy to write (one call validates many properties)
    - Easy to read (named parameters show intent)
    - Easy to maintain (shared validation logic)
    - Comprehensive (test all or just some properties)
    - Debuggable (helpful failure messages)

2. Design Philosophy

    One method per element type with builder-pattern configuration:
    
        element.assert_verbatim()
            .mode(VerbatimType::InFlow)
            .label("python")
            .parameters(&[("version", "3.11")])
            .line_count(3);
    
    Or using struct initialization:
    
        assert_verbatim(element, VerbatimExpected {
            mode: Some(VerbatimType::InFlow),
            label: Some("python"),
            parameters: Some(hashmap!{"version" => "3.11"}),
            line_count: Some(3),
            ..Default::default()
        });
    
    Benefits:
    - One function call tests multiple properties
    - Optional fields: test only what matters
    - Named parameters: clear intent
    - Reusable validation logic
    - Easy to extend with new properties

3. Core Assertion Structure

    3.1. Per-Element Expected Structs
    
        Each element gets an Expected struct with Optional fields:
        
        ParagraphExpected:
            text: Option<&str>              // Exact text match
            text_contains: Option<&str>     // Contains substring
            text_matches: Option<Regex>     // Regex match
            has_formatting: Option<bool>    // Has TextTransform beyond Identity
            line_count: Option<usize>       // Source line count
            annotation_count: Option<usize> // Number of annotations
            has_annotation: Option<&str>    // Has specific annotation label
            has_parameter: Option<(&str, &str)> // Has parameter key=value
            
        ListExpected:
            style: Option<NumberingStyle>   // Plain, Numerical, etc.
            item_count: Option<usize>       // Number of items
            item_text: Option<Vec<&str>>    // Text of each item
            has_nested: Option<Vec<bool>>   // Which items have nesting
            annotation_count: Option<usize>
            
        DefinitionExpected:
            term: Option<&str>              // Term text
            term_contains: Option<&str>     // Term contains substring
            content_count: Option<usize>    // Elements in content
            has_content: Option<bool>       // Non-empty content
            content_types: Option<Vec<ElementType>> // Child element types
            
        SessionExpected:
            title: Option<&str>             // Title text
            title_contains: Option<&str>    // Title contains substring
            numbering: Option<&str>         // Numbering marker
            is_numbered: Option<bool>       // Has numbering
            child_count: Option<usize>      // Children count
            has_subsession: Option<bool>    // Contains nested session
            
        VerbatimExpected:
            mode: Option<VerbatimType>      // InFlow or Stretched
            label: Option<&str>             // Label value
            label_starts_with: Option<&str> // Label prefix
            title: Option<&str>             // Title text
            line_count: Option<usize>       // Content line count
            content_contains: Option<&str>  // Content has substring
            parameters: Option<HashMap<&str, &str>> // All parameters
            has_parameter: Option<(&str, &str)> // Specific parameter
            
        AnnotationExpected:
            label: Option<&str>             // Label value
            content_type: Option<AnnotationContentType> // Inline or Block
            has_content: Option<bool>       // Non-empty content
            content_text: Option<&str>      // Content text
            parameters: Option<HashMap<&str, &str>>
            
    3.2. Shared Property Validation
    
        Reusable validators for common properties:
        
        validate_parameters(element, expected: &HashMap<&str, &str>)
            Check all key-value pairs match
            
        validate_annotations(element, expected_count, expected_labels)
            Check annotation presence and count
            
        validate_text_content(element, text, contains, matches)
            Check text using appropriate method
            
        validate_token_count(element, expected)
            Check token sequence length

4. Implementation Approach

    4.1. Module Organization
    
        File: tests/assertions/mod.rs
            - Expected structs for all elements
            - Core assertion functions (one per element)
            - Shared validation utilities
            
        File: tests/assertions/validators.rs
            - validate_parameters()
            - validate_annotations()
            - validate_text_content()
            - validate_tokens()
            
        File: tests/assertions/builders.rs (optional)
            - Builder pattern helpers
            - Fluent API for Expected structs
            
    4.2. Expected Struct Pattern
    
        All fields optional for flexibility:
            #[derive(Default)]
            pub struct VerbatimExpected<'a> {
                pub mode: Option<VerbatimType>,
                pub label: Option<&'a str>,
                pub title: Option<&'a str>,
                pub line_count: Option<usize>,
                pub content_contains: Option<&'a str>,
                pub parameters: Option<HashMap<&'a str, &'a str>>,
                pub has_parameter: Option<(&'a str, &'a str)>,
                pub annotation_count: Option<usize>,
            }
            
    4.3. Assertion Function Signature
    
        One function per element type:
            pub fn assert_verbatim<'a>(
                element: &SessionContainerElement,
                expected: VerbatimExpected<'a>
            ) -> &VerbatimBlock {
                // 1. Downcast to VerbatimBlock (panic if wrong type)
                // 2. Validate each Some() property
                // 3. Return reference for further testing
            }
            
    4.4. Builder Pattern (Optional Alternative)
    
        Fluent API for more ergonomic syntax:
            impl<'a> VerbatimExpected<'a> {
                pub fn new() -> Self { Self::default() }
                pub fn mode(mut self, m: VerbatimType) -> Self { 
                    self.mode = Some(m); self 
                }
                pub fn label(mut self, l: &'a str) -> Self { 
                    self.label = Some(l); self 
                }
                // ... etc
            }
            
        Usage:
            assert_verbatim(element, VerbatimExpected::new()
                .mode(VerbatimType::InFlow)
                .label("python")
                .line_count(3)
            );

5. Usage Examples

    5.1. Simple Validation (Few Properties)
    
        Test one or two properties:
            let para = parse_paragraph(&source).unwrap();
            
            assert_paragraph(&para, ParagraphExpected {
                text_contains: Some("expected content"),
                ..Default::default()
            });
            
        Or with builder:
            assert_paragraph(&para, ParagraphExpected::new()
                .text_contains("expected content")
            );
                
    5.2. Comprehensive Validation (Many Properties)
    
        Test multiple properties in one call:
            let verbatim = parse_verbatim(&source).unwrap();
            
            assert_verbatim(&verbatim, VerbatimExpected {
                mode: Some(VerbatimType::InFlow),
                label: Some("python"),
                title: Some("Example code"),
                line_count: Some(5),
                content_contains: Some("def "),
                has_parameter: Some(("version", "3.11")),
                ..Default::default()
            });
            
    5.3. List Validation with Item Details
    
        Test code:
            let list = parse_list(&source).unwrap();
            
            assert_list(&list, ListExpected {
                style: Some(NumberingStyle::Plain),
                item_count: Some(3),
                item_text: Some(vec!["First", "Second", "Third"]),
                has_nested: Some(vec![false, true, false]),
                ..Default::default()
            });
            
    5.4. Session with Nested Validation
    
        Test code:
            let session = parse_session(&source).unwrap();
            
            // First validate session itself
            assert_session(&session, SessionExpected {
                title: Some("Introduction"),
                numbering: Some("1."),
                child_count: Some(2),
                ..Default::default()
            });
            
            // Then validate specific children
            assert_paragraph(&session.content.content[0], ParagraphExpected {
                text_contains: Some("welcome"),
                ..Default::default()
            });

6. Error Message Design

    6.1. Principles
    
        - Show property name, expected value, actual value
        - Include element context
        - Show element path when available
        - Format for easy reading
        
    6.2. Example Error Messages
    
        Property mismatch:
            "Verbatim assertion failed: label mismatch
             Expected label: 'python'
             Actual label: 'javascript'
             Element: VerbatimBlock at line 15, column 4"
             
        Count mismatch:
            "List assertion failed: item_count mismatch
             Expected: 3 items
             Actual: 2 items
             List items found:
               [0] 'First item'
               [1] 'Second item'"
               
        Type mismatch:
            "Element type assertion failed
             Expected: VerbatimBlock
             Actual: ParagraphBlock
             Element at: document.content[2]"
             
        Content mismatch:
            "Paragraph assertion failed: text_contains check
             Expected to contain: 'introduction'
             Actual text: 'This is a conclusion paragraph'
             Note: Text search is case-sensitive"

7. Implementation Phases

    Phase 1: Expected Structs
        - Define *Expected structs for all elements
        - Add Default derives
        - Document all fields with comments
        
    Phase 2: Core Assertion Functions
        - Implement assert_paragraph, assert_list, etc.
        - Downcast and type checking
        - Property validation logic
        
    Phase 3: Shared Validators
        - validate_parameters helper
        - validate_annotations helper
        - validate_text_content helper
        - Reusable across all elements
        
    Phase 4: Builder Pattern (Optional)
        - Add builder methods to Expected structs
        - Enable fluent API
        - Improves ergonomics further

8. Testing the Assertions

    The assertion helpers themselves need tests:
    
    - Test that valid structures pass
    - Test that invalid structures fail with good messages
    - Test chainability works
    - Test macro expansion is correct
    - Test error messages are helpful

9. Integration with Corpora

    Assertions should work seamlessly with corpora:
    
        #[test]
        fn test_paragraph_simple() {
            let corpus = TxxtCorpora::load("txxt.core.spec.paragraph.valid.simple").unwrap();
            let para = parse_paragraph(&corpus.source_text).unwrap();
            
            // Use assertion helpers
            assert_is_paragraph(&para)
                .assert_text_contains("paragraph")
                .assert_has_no_annotations();
        }

10. Implementation Example

    Expected struct:
        #[derive(Default)]
        pub struct VerbatimExpected<'a> {
            pub mode: Option<VerbatimType>,
            pub label: Option<&'a str>,
            pub line_count: Option<usize>,
            pub content_contains: Option<&'a str>,
            pub parameters: Option<HashMap<&'a str, &'a str>>,
        }
        
    Assertion function:
        pub fn assert_verbatim<'a>(
            element: &SessionContainerElement,
            expected: VerbatimExpected<'a>
        ) -> &VerbatimBlock {
            // Type check and downcast
            let verbatim = match element {
                SessionContainerElement::Verbatim(v) => v,
                other => panic!("Expected VerbatimBlock, found {:?}", other),
            };
            
            // Validate each Some() property
            if let Some(expected_mode) = expected.mode {
                assert_eq!(verbatim.verbatim_type, expected_mode, 
                    "Verbatim mode mismatch");
            }
            
            if let Some(expected_label) = expected.label {
                assert_eq!(verbatim.label, expected_label,
                    "Verbatim label mismatch");
            }
            
            if let Some(expected_count) = expected.line_count {
                let actual = verbatim.content.ignore_lines.len();
                assert_eq!(actual, expected_count,
                    "Verbatim line count mismatch");
            }
            
            if let Some(expected_params) = expected.parameters {
                validate_parameters(&verbatim.parameters, &expected_params);
            }
            
            // Return reference for further use
            verbatim
        }
        
    Shared validator:
        fn validate_parameters(
            actual: &Parameters,
            expected: &HashMap<&str, &str>
        ) {
            for (key, expected_value) in expected {
                let actual_value = actual.get(key);
                assert_eq!(
                    actual_value, Some(expected_value),
                    "Parameter '{}' mismatch. Expected: '{}', Actual: {:?}",
                    key, expected_value, actual_value
                );
            }
        }

11. Testing Strategy Integration

    Works seamlessly with corpora system:
    
        #[test]
        fn test_verbatim_with_params() {
            let corpus = TxxtCorpora::load(
                "txxt.core.spec.verbatim.valid.with-parameters"
            ).unwrap();
            
            let verbatim = parse_verbatim(&corpus.source_text).unwrap();
            
            // One call validates everything
            assert_verbatim(&verbatim, VerbatimExpected {
                mode: Some(VerbatimType::InFlow),
                label: Some("python"),
                has_parameter: Some(("style", "functional")),
                line_count: Some(9), // From quicksort example
                content_contains: Some("def quicksort"),
                ..Default::default()
            });
        }

:: note :: This builder-pattern assertion design provides maximum ergonomics with minimal code. One function per element, optional properties, clear intent, and reusable validation logic.

