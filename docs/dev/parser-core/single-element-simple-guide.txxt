:: title :: Single Element Simple Implementation Guide
:: author :: Arthur Debert
:: pub-date :: 2025-01-12
:: status :: Implementation Guide

This guide covers implementing parser support for single elements in their simple forms. This is Phase 1 of the parser implementation plan.

1. Overview

    This guide covers:
    - Implementing parser support for individual element types
    - Working with simple (non-complex) element variations
    - Validating and fixing AST assertions based on real-world data
    - Testing with isolated element corpora

    Key principle: Each element is implemented in isolation first, then integrated.

2. Prerequisites

    Before starting, ensure you understand:
    - Element specifications in `docs/specs/elements/<element>.txxt`
    - AST node definitions in `src/ast/elements/<element>.rs`
    - Existing assertion framework in `tests/assertions/elements/<element>/`
    - Corpora system in `docs/dev/parser-core/Parser-1.4.1-per-element-corpora.txxt`

3. Implementation Workflow

    3.1. Step 1: Load Test Corpus

        Load the simple test corpus for your element:
        ```rust
        use tests::corpora::TxxtCorpora;
        let corpus = TxxtCorpora::load("txxt.core.spec.<element>.valid.simple")?;
        ```

        Available corpora patterns:
        - `txxt.core.spec.paragraph.valid.simple` - Single paragraph
        - `txxt.core.spec.list.valid.simple` - Simple list
        - `txxt.core.spec.definition.valid.simple` - Simple definition
        - `txxt.core.spec.session.valid.simple` - Simple session

    3.2. Step 2: Write Failing Test

        Create a test that will fail until parser is implemented:
        ```rust
        #[test]
        fn test_parse_simple_<element>() {
            let corpus = TxxtCorpora::load("txxt.core.spec.<element>.valid.simple").unwrap();
            let result = parse_<element>(&corpus.source_text);
            assert!(result.is_ok());
            
            let element = result.unwrap();
            // Basic structure validation
            assert_eq!(element.element_type(), ElementType::Block);
        }
        ```

    3.3. Step 3: Implement Parser Logic

        Location: `src/parser/pipeline/parse_blocks.rs` (or create element-specific module)

        Key implementation points:
        - Follow element specification exactly
        - Use existing AST types from `src/ast/elements/`
        - Handle token patterns correctly
        - Preserve position information from tokens

        Example structure:
        ```rust
        pub fn parse_<element>(tokens: &[Token]) -> Result<ElementNode, ParseError> {
            // 1. Validate token patterns match element spec
            // 2. Extract element-specific data (title, content, parameters)
            // 3. Create AST node with proper structure
            // 4. Return typed element
        }
        ```

    3.4. Step 4: Run Test and Iterate

        ```bash
        cargo test test_parse_simple_<element>
        ```

        Iterate until test passes with correct AST structure.

    3.5. Step 5: Validate and Fix Assertions

        **Critical Step**: The existing assertions are based on spec + AST definitions, not real data. You must validate and fix them.

        ```rust
        #[test]
        fn test_<element>_assertions_with_real_data() {
            let corpus = TxxtCorpora::load("txxt.core.spec.<element>.valid.simple").unwrap();
            let element = parse_<element>(&corpus.source_text).unwrap();
            
            // Test assertion with real data
            let container_element = SessionContainerElement::<Element>(element);
            assert_<element>(&container_element, <Element>Expected {
                // Test with actual values from corpus
                ..Default::default()
            });
        }
        ```

        Common assertion fixes needed:
        - Field names may not match actual AST structure
        - Expected values may be incorrect
        - Validation logic may need adjustment
        - Missing fields in Expected struct

    3.6. Step 6: Test Multiple Simple Cases

        Test the element with multiple simple variations:
        ```rust
        #[test]
        fn test_<element>_multiple_simple_cases() {
            let cases = vec![
                "txxt.core.spec.<element>.valid.simple",
                "txxt.core.spec.<element>.valid.simple.alt1",
                "txxt.core.spec.<element>.valid.simple.alt2",
            ];
            
            for case in cases {
                let corpus = TxxtCorpora::load(case).unwrap();
                let result = parse_<element>(&corpus.source_text);
                assert!(result.is_ok(), "Failed to parse case: {}", case);
            }
        }
        ```

4. Element-Specific Implementation Notes

    4.1. Paragraphs

        - Simplest element to implement
        - Foundation for all other elements
        - Test with single-line and multi-line content
        - Validate text content preservation

    4.2. Sessions

        - Require at least one content element
        - Implement after paragraphs are working
        - Test with flat and nested structures
        - Validate title and content separation

    4.3. Lists

        - Handle different marker types (-, 1., a.)
        - Test with single and multiple items
        - Validate item content structure

    4.4. Definitions

        - Handle term :: definition pattern
        - Test with simple and complex terms
        - Validate term and definition separation

    4.5. Verbatim Blocks

        - Handle title: pattern
        - Test with different verbatim types
        - Validate content preservation

    4.6. Annotations

        - Handle :: label :: pattern
        - Test with different label types
        - Validate annotation attachment

5. Assertion Validation Process

    5.1. Identify Assertion Issues

        Common problems with existing assertions:
        - Field names don't match AST structure
        - Expected values are incorrect
        - Validation logic is wrong
        - Missing validation for important fields

    5.2. Fix Assertion Implementation

        Location: `tests/assertions/elements/<element>/assertions.rs`

        Steps:
        1. Compare Expected struct with actual AST structure
        2. Update field names to match
        3. Fix validation logic
        4. Add missing validations
        5. Test with real data

    5.3. Update Expected Struct

        Location: `tests/assertions/elements/<element>/expected.rs`

        Ensure all fields match actual AST structure and are properly optional.

6. Testing Patterns

    6.1. Basic Element Test

        ```rust
        #[test]
        fn test_<element>_basic() {
            let corpus = TxxtCorpora::load("txxt.core.spec.<element>.valid.simple").unwrap();
            let result = parse_<element>(&corpus.source_text);
            
            assert!(result.is_ok());
            let element = result.unwrap();
            
            // Validate basic structure
            assert_eq!(element.element_type(), ElementType::Block);
            
            // Validate with assertions
            let container_element = SessionContainerElement::<Element>(element);
            assert_<element>(&container_element, <Element>Expected {
                // Specify only what you want to validate
                ..Default::default()
            });
        }
        ```

    6.2. Error Case Test

        ```rust
        #[test]
        fn test_<element>_invalid() {
            let corpus = TxxtCorpora::load("txxt.core.spec.<element>.invalid.case").unwrap();
            assert!(corpus.is_error_case());
            
            let result = parse_<element>(&corpus.source_text);
            assert!(result.is_err());
            
            if let Err(error) = result {
                assert!(error.to_string().contains(corpus.expected_error().unwrap()));
            }
        }
        ```

    6.3. Snapshot Test

        ```rust
        #[test]
        fn test_<element>_snapshot() {
            let corpus = TxxtCorpora::load("txxt.core.spec.<element>.valid.simple").unwrap();
            let ast = parse_<element>(&corpus.source_text).unwrap();
            
            insta::assert_yaml_snapshot!(ast);
        }
        ```

7. Integration Testing

    7.1. Test with Lexer Integration

        ```rust
        #[test]
        fn test_<element>_lexer_integration() {
            let corpus = TxxtCorpora::load("txxt.core.spec.<element>.valid.simple").unwrap();
            
            // Test full pipeline: text -> tokens -> blocks -> element
            let tokens = tokenize(&corpus.source_text)?;
            let token_tree = TokenTreeBuilder::new().build_tree(tokens)?;
            let blocks = BlockParser::new().parse_blocks(token_tree)?;
            
            // Find our element in the blocks
            let element = blocks.iter()
                .find(|b| matches!(b, ElementNode::<Element>(_)))
                .unwrap();
            
            // Validate it's correct
            assert_<element>(element, <Element>Expected {
                ..Default::default()
            });
        }
        ```

    7.2. Test with Assembler Integration

        ```rust
        #[test]
        fn test_<element>_assembler_integration() {
            let corpus = TxxtCorpora::load("txxt.core.spec.<element>.valid.simple").unwrap();
            
            // Test full pipeline including assembler
            let document = parse_document(&corpus.source_text)?;
            
            // Validate document structure
            assert!(document.contains_element_type(ElementType::<Element>));
        }
        ```

8. Common Pitfalls

    8.1. Assertion Issues

        ❌ Don't assume existing assertions are correct
        ❌ Don't skip assertion validation step
        ❌ Don't ignore assertion test failures

        ✅ Do validate assertions with real data
        ✅ Do fix assertion implementations
        ✅ Do test assertions thoroughly

    8.2. Implementation Issues

        ❌ Don't implement complex cases in simple phase
        ❌ Don't skip error case testing
        ❌ Don't ignore position information

        ✅ Do follow element specification exactly
        ✅ Do test with multiple simple cases
        ✅ Do preserve token position information

9. Success Criteria

    An element implementation is complete when:
    - [ ] All simple test cases pass
    - [ ] Assertions work correctly with real data
    - [ ] Error cases are handled properly
    - [ ] Integration tests pass
    - [ ] Snapshot tests are updated
    - [ ] Documentation is updated

10. Next Steps

    After completing single element simple implementation:
    1. Move to mixed ensemble testing (see Mixed Ensemble Guide)
    2. Implement next element in sequence
    3. Add complex cases (see Complex Element Guide)

:: note :: This guide focuses on single element implementation. For mixed ensembles or complex cases, see the respective guides.
