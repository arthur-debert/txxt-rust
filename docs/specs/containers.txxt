:: title :: Proposal: Uniform Content Representation in the AST
:: author :: adebert

This document explain containers in txxt. 

Elements can have a number of children of the same type: paragraphs can have multiple lines, text lines can have multiple test spans, lists can have multiple lists tems. The only type of nodes that can host different block elements are containers. 

In the ast, containers hold a node's children.  And it's children are always +1 indented. 

1. What are Containers
 
	Containers are structureal elements that represnt's an element's children, hence always carry a parent-child signification. Visually containers's children are +1 indented, but othersiwe have no content ontheir own (no label, attributes, etc) . Every indentation , outside verbatim blocks denotes  container's children.

	There are two types of containers: content and session ones. The only difference between them is that session containers can hold <session> elmeents, which content containers cannot. Sessions are high level navigtional and structural elements, you don't want a list item creating a new document session. Session containers must be surrrounded by blank lines.
	
	For example, here Session 1 (1. What are Containers) has a session container where it's 3 pargraph children are, hence they are +1 indented.

2. Session Containers and AST Structure

	While visually natural, our intuition tends to mistake how this is captured by the ast.
	Take this sesison and ast: 
		├── session
		│ 	├── session-heading
		│ 	├── session-container
		│ 	│ 	├── paragraph
				... other session children follow
	(tree)
	 
	 Another way to say it: a session must have a session title and at least a child elemnt (in it's contaner). The key here is that the sessoin element is not the container. The heading is inside the session elemnt, but not in it's children container, a title is not the session's child, it's more like an attribute.

	 At first glance, we tend to expect the session elment to be the containers, hence the disconect. Were that the case and the heading would be also +1 indented.

3. Content Containers In Depth

	Let's look at nested lists. 
	For the following examples I'll omit the fact that a list-item has a decoration and text items inside, see  the full represntation [1].

	
	Here is what the ast is like. 
	Lists have the following structure: 
		├── list
		│ 	├── list-item
		│ 	│ 	├── text: Bread
		│ 	│ 	├── content-container
	(txxt)

	In a flat list, the list's items container is empty. Now consider nested lists: 
	1.1 Milk
	1.2 Bread
		2.1 Wheat
	1.3 Eggs

	Here is what the ast looks like: 
		├── list
		│ 	├── list-item: Milk
		│ 	├── list-item: Bred
		│ 	│ 	├── content-container
		│ 	│ 	│   ├── list
		│ 	│ 	│   │ 	└── list-item: Wheat
		│ 	├── list-item: Eggs
	(tree)

	As one can see, the content is a recursive structure. And the parser is so structured.
	Of course, the outer list iteself is inside another container , say a session container.

	The root elment of a document is a session container.

4. More Content Containers

	Note that content containers can hold all elements but sessions. 
	Hence: 
	- This is a list
	- Whose second item has a pargraph as it's child.
		And we could have a long text here. 
		Or a verbatim block: 
			alert('recursion, here be dragons')
		(javascript)
	- And the list goes on and on.

	Do note that session-containers must be enclosed in blank lines and content ones do not.
	Benefits:
	-   Uniform Parsing: The logic for parsing the children of a `ListItem`, a `Definition`, and a multi-line `Annotation` becomes -identical-. The parser simply recurses into the `ContentContainer`.  -   Eliminates Special Casing: The ambiguity of "what does it mean to be a child of a `ListItem`?" disappears. This dramatically simplifies the `AstBuilder`. 
	-   Clear Structure: The AST now has a predictable, easy-to-navigate structure for all nested content.

5. Ingore Container

	In verbatim elements, their content, their childres is a list with 0 or more lines.
	Thes live with a  Ignore Container, that is, a container whose children will be lines we should not process.
	

Notes: 
	1. List items full ast
		For brevity's sake we've simplified the list-item representation as `list-item: foo`
		The full ast : 
			├── list-item
				├── marker: -
				├── text-span: foo


