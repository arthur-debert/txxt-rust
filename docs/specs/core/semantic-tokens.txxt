:: title :: txxt Semantic Tokens Reference
:: author :: Arthur Debert
:: pub-date :: 2025-10-18

This document is part of the txxt syntax tree documentation. Together with @grammar.txxt, it defines the complete syntax and structure of the txxt format.

- @scanner-tokens.txxt defines the low-level scanner tokens
- @semantic-tokens.txxt (this document) defines semantic node types
- @grammar.txxt defines how blocks are constructed from scanner tokens

This document defines the semantic tokens used in the txxt parsing pipeline. Semantic tokens are higher-level constructs that bridge the gap between low-level scanner tokens and block elements, providing structured components for parsing stages.

1. Introduction

    The Semantic Token Parsing phase transforms scanner tokens into semantic tokens. This intermediate representation provides structured, reusable components that make subsequent block parsing simpler and more direct.

    Semantic tokens describe the *syntactic shape* of content, not its final semantic role (e.g., a paragraph vs. a definition term). They bridge the gap between format-only scanner tokens and semantic block elements.

2. Semantic Token Definitions

    TxxtMarker::
        The fundamental :: marker used across annotations, definitions, and verbatim blocks.
        Identifies txxt structural elements and provides disambiguation anchor points.
        Essential for recognizing txxt syntax vs plain text.

    Colon::
        Colon punctuation marker used for parameter separation.
        Preserves syntactic meaning for parameter parsing and error reporting.
        Allows AST construction phase to identify misplaced syntactic markers with precision.

    Label::
        Structured identifier component for annotations and verbatim blocks.
        Supports namespaced identifiers like "python", "org.example.custom".
        Reusable across annotation labels and verbatim labels.

    Parameters::
        Key-value metadata component used in annotations and verbatim elements.
        Structured parameter list with proper key-value pair parsing.
        Example: "version=3.11,style=functional,author=\"Jane Doe\""

    Sequence Marker::
        List and session numbering component.
        Handles numeric (1.), alphabetic (a.), roman (i.), and plain (-) markers,
        in both regular (2.) and extended (1.3.b) forms.
        Critical for session vs list disambiguation logic, and between lists and paragraphs.

    Text Span::
        Basic text content component without special formatting.
        Building block for larger line constructs.
        Preserves source span information for error reporting.

    Sequence Text Line::
        Line beginning with sequence marker followed by text content.
        Combines Sequence Marker and Text Span components.
        Used for list items, session titles, and numbered paragraphs.

    Plain Text Line::
        Simple text content without special markers or structure.
        Contains single Text Span component.
        Default fallback for unstructured content.

    Ignore Line::
        Preserved exactly as written without txxt processing.
        Stored as raw string with source span tracking.
        Consumed by a verbatim block.

    Blank Line::
        Line containing only whitespace or completely empty.
        Critical for whitespace enclosure detection in sessions vs lists.
        Sessions require blank line separation; lists cannot have blank lines between items.

    Indent::
        Indentation marker passed through unchanged from scanner tokens.
        Marks the beginning of a new indentation level.
        Used for block structure and nesting.

    Dedent::
        Dedentation marker passed through unchanged from scanner tokens.
        Marks the end of an indentation level.
        Used for block structure and nesting.

    Annotation::
        Annotation semantic token combining txxt markers with labels and optional content.
        Composition: TxxtMarker + Whitespace + Text + Whitespace + TxxtMarker + Text?
        Used for metadata elements that attach structured information to other elements.

    Definition::
        Definition semantic token combining text with txxt markers.
        Composition: Text + Whitespace + TxxtMarker (simple) or Text + Colon + Text + Whitespace + TxxtMarker (parameterized)
        Used for structured elements that define terms, concepts, and entities.

    Verbatim Block::
        Verbatim block semantic token using wall architecture.
        Composition: VerbatimTitle + IndentationWall + IgnoreTextSpan + VerbatimLabel
        Used for content that preserves exact formatting and spacing.

3. Token Composition Patterns

    Semantic tokens are composed from scanner tokens using well-defined patterns:

    3.1. Annotation Composition

        Annotations combine txxt markers with labels and optional content:
        `TxxtMarker` + `Whitespace` + `Text` + `Whitespace` + `TxxtMarker` + `Text`?

    3.2. Definition Composition

        Definitions combine text with txxt markers, optionally with parameters:
        `Text` + `Whitespace` + `TxxtMarker` (simple definition)
        `Text` + `Colon` + `Text` + `Whitespace` + `TxxtMarker` (parameterized definition)

    3.3. Verbatim Composition

        Verbatim blocks use wall architecture:
        `VerbatimTitle` + `IndentationWall` + `IgnoreTextSpan` + `VerbatimLabel`

    3.4. Parameter Composition

        Parameters combine identifiers, equals signs, and values:
        `Identifier` + `Equals` + `Value` + `Comma`?

    3.5. Structural Token Composition

        Structural tokens are passed through unchanged from scanner tokens:
        `Indent` and `Dedent` tokens preserve indentation structure
        `BlankLine` tokens preserve whitespace structure

    3.6. Complex Semantic Token Composition

        Complex semantic tokens combine multiple simpler tokens:
        - `Annotation`: Combines multiple tokens into structured metadata
        - `Definition`: Combines text and markers into structured definitions
        - `VerbatimBlock`: Combines verbatim components into content blocks

4. Separation of Concerns

    The semantic token layer provides clear separation between:
    - Format recognition (scanner tokens)
    - Syntactic structure (semantic tokens)
    - Semantic meaning (block elements)

    This separation enables:
    - Cleaner parsing logic
    - Better error handling
    - Easier testing and debugging
    - More maintainable code

5. File Organization

    Semantic tokens (high-level tokens) are organized in the CST module:

    5.1. High-Level Token Definitions

        - `src/cst/high_level_tokens.rs`: HighLevelToken enum and types
        - `src/cst/primitives.rs`: Shared Position and SourceSpan types
        - `src/lexer/pipeline/`: High-level token processing

    5.2. CST vs AST Architecture

        The Concrete Syntax Tree (CST) contains all token types:
        - Scanner tokens (low-level, character-precise)
        - High-level tokens (semantic tokens, line-level)

        The Abstract Syntax Tree (AST) contains semantic elements:
        - Block elements (ParagraphBlock, ListBlock, SessionBlock)
        - Inline elements (TextSpan, BoldSpan, CitationSpan)
        - Container elements (ContentContainer, SessionContainer)

:: note :: This semantic tokens reference defines the intermediate representation used in txxt parsing. For complete block grammar, see @grammar.txxt.
