Parser 1.1.1 AST Prep: Tree Traversal

1. Overview

    Implement a tree traversal API using ego-tree for efficient parent/child/sibling navigation, with a powerful query interface and visitor pattern for AST analysis. The API prioritizes simplicity and fast delivery over the complexity of rowan-style red-green trees, with a potential migration path to rowan for advanced LSP features if needed.

2. Design Goals

    2.1. Simple and Fast

        - Use ego-tree for O(1) parent/child/sibling access
        - Vec-backed memory efficient implementation
        - No lifetime complexity from borrowing original document
        - Pragmatic approach delivering value quickly

    2.2. Query-Focused

        - Method chaining API for composable queries
        - Type-based filtering (find_by_type)
        - Text search capabilities (text_contains, text_matches)
        - XPath-like selectors for complex queries
        - Annotation and parameter filtering

    2.3. Extensible

        - Visitor pattern for custom AST processing
        - Trait-based interface for uniform navigation
        - Result/Error generic types for flexible processing
        - Foundation for future LSP features

3. Architecture

    3.1. Core Components

        - TraversableDocument: Wrapper around ego-tree with Document
        - ElementWrapper: Boxed dyn TxxtElement + Send + Sync for tree storage
        - DocumentQuery: Iterator-based query builder with filters
        - Traversable trait: Generic interface for tree navigation
        - ElementVisitor: Type-safe visitor pattern for processing

    3.2. Tree Building

        - from_document(): Convert Document to ego-tree recursively
        - build_session_container_recursive(): Traverse SessionContainer elements
        - build_content_container_recursive(): Traverse ContentContainer elements
        - ElementAdapter: Uniform wrapper for all AST element types
        - Proper parent-child relationships maintained

4. API Surface

    4.1. Basic Navigation

        Methods on TraversableDocument and Traversable trait:
        
        - root(): Get document root node
        - parent(node): Get parent of node (O(1))
        - children(node): Get all children (O(1))
        - siblings(node): Get siblings at same level
        - descendants(node): Depth-first traversal of all descendants
        - ancestors(node): Walk up to root from node

    4.2. Query Interface

        Method chaining with DocumentQuery:
        
        - query(): Start new query on entire tree
        - find_by_type(ElementType): Filter by Span/Line/Block/Container
        - text_contains(needle): Filter elements containing text
        - text_matches(regex): Filter elements matching pattern
        - has_annotation(key): Filter elements with annotation
        - has_parameter(key, value): Filter by parameter
        - find(predicate): Custom filter function
        - collect(): Execute query and return results

    4.3. XPath Selectors

        XPath-inspired syntax for document queries:
        
        Axes:
            - //Type: Descendant axis (recursive)
            - /Type: Child axis (direct children)
            - .: Self axis (current node)
            - ..: Parent axis (one level up)
            - *: Wildcard (any element type)
        
        Element Types:
            - Block: All block elements
            - Container: All container elements
            - Line: All line elements
            - Span: All span elements
        
        Predicates:
            - [@name="value"]: Parameter filtering
            - [text()="content"]: Text content filtering
        
        Examples:
            - "//Block": All blocks anywhere
            - "//Container[@type='session']": Session containers
            - "//Block[text()='hello']": Blocks with specific text
            - "//*": All elements (wildcard)

    4.4. Visitor Pattern

        ElementVisitor trait for extensible processing:
        
        Associated types:
            - Result: Success type returned from visitor
            - Error: Error type for visitor failures
        
        Visit methods (all with default fallback):
            - visit_element(element): Default handler
            - visit_paragraph(para): Paragraph-specific
            - visit_list(list): List-specific
            - visit_definition(def): Definition-specific
            - visit_verbatim(verb): Verbatim-specific
            - visit_session(sess): Session-specific
            - visit_annotation(ann): Annotation-specific
            - visit_container(cont): Container-specific
        
        Usage:
            - Implement visitor trait with custom logic
            - Call walk() or walk_nodes() to apply visitor
            - Type-safe dispatch to specific handlers

    4.5. Tree Analysis Utilities

        Helper functions for common operations:
        
        - element_type_stats(): Count elements by type
        - tree_depth(): Measure maximum nesting level
        - leaf_nodes(): Find terminal elements without children
        - walk(visitor): Apply visitor to all nodes
        - walk_nodes(nodes, visitor): Apply visitor to subset

5. Implementation Phases

    5.1. Phase 1: Foundation (commit fe664bf)

        - ego-tree dependency integration
        - TraversableDocument wrapper structure
        - ElementWrapper with TxxtElement trait object
        - Basic DocumentQuery interface
        - Type-based filtering foundation
        - Text search method stubs

    5.2. Phase 2: Tree Building (commit c981f54)

        - Recursive tree building from containers
        - ElementAdapter for uniform element wrapping
        - Proper handling of all element types
        - Text extraction for query filters
        - Test coverage for tree construction
        - Working text search functionality

    5.3. Phase 3: XPath Selectors (commit b8d2165)

        - XPath parser for selector syntax
        - Support for axes (descendant, child, self, parent)
        - Element type matching with wildcards
        - Attribute and text predicates
        - Integration with DocumentQuery
        - Structured error handling

    5.4. Phase 4: Visitor and Utilities (commit ee4e372)

        - Traversable trait for generic interface
        - ElementVisitor pattern implementation
        - Accept pattern on ElementAdapter
        - Tree analysis utility functions
        - Statistics and depth measurement
        - Complete test coverage

6. Usage Examples

    6.1. Basic Queries

        Example code:
            let doc = parse_document(source);
            let traversable = TraversableDocument::from_document(&doc);
            
            // Find all paragraphs
            let paras = traversable.query()
                .find_by_type(ElementType::Block)
                .collect();
            
            // Text search
            let matches = traversable.query()
                .text_contains("Hello")
                .collect();
            
            // Parameter filtering
            let tagged = traversable.query()
                .has_parameter("ref", "intro")
                .collect();

    6.2. XPath Queries

        Example code:
            // Find all session blocks
            let sessions = traversable.xpath("//Block[@type='session']")?;
            
            // Find direct children only
            let children = traversable.xpath("/Block")?;
            
            // Complex nested query
            let results = traversable.xpath("//Container//Block[text()='key']")?;

    6.3. Visitor Pattern

        Example code:
            struct ParagraphCounter { count: usize }
            
            impl ElementVisitor for ParagraphCounter {
                type Result = ();
                type Error = ();
                
                fn visit_paragraph(&mut self, _para: &ParagraphBlock) -> Result<(), ()> {
                    self.count += 1;
                    Ok(())
                }
            }
            
            let mut counter = ParagraphCounter { count: 0 };
            traversable.walk(&mut counter)?;
            println!("Found {} paragraphs", counter.count);

    6.4. Navigation

        Example code:
            let root = traversable.root();
            let children = traversable.children(root);
            
            for child in children {
                let parent = traversable.parent(child);
                let siblings = traversable.siblings(child);
                let descendants = traversable.descendants(child);
            }

7. Language Server Applications

    7.1. Hover Information

        - Use navigation to find element at position
        - Extract text content and metadata
        - Display annotations and parameters

    7.2. Go-to-Definition

        - Query for reference targets
        - XPath to find matching definitions
        - Navigate to source position via tokens

    7.3. Find References

        - Query all reference spans
        - Filter by target identifier
        - Collect all usage positions

    7.4. Workspace Symbols

        - Use visitor to collect all definitions
        - Extract session titles as symbols
        - Gather annotations for document outline

    7.5. Document Analysis

        - Statistics for structure insights
        - Depth measurement for complexity
        - Leaf detection for completeness

8. Performance Characteristics

    - Tree building: O(n) where n = number of elements
    - Parent/child/sibling access: O(1) via ego-tree
    - XPath descendant queries: O(n) tree traversal
    - Text search: O(n) with string matching
    - Memory: Single copy of element tree in Vec-backed storage

9. Testing Coverage

    Tests validate all functionality:
    
    - test_tree_building_with_content(): Proper tree construction
    - test_text_search_functionality(): Query operations
    - test_xpath_parsing(): XPath parser correctness
    - test_xpath_integration(): End-to-end XPath queries
    - test_xpath_error_handling(): Robust error handling
    - test_traversable_trait(): Uniform interface validation
    - test_visitor_pattern(): Extensible processing
    - test_tree_utilities(): Analysis capabilities
    
    All 566 tests pass including existing functionality.

10. Future Extensions

    10.1. Potential Enhancements

        - More XPath features (position(), last(), more axes)
        - Query result caching for repeated queries
        - Incremental updates to tree structure
        - Parallel visitor processing for large documents

    10.2. Migration Path

        If advanced LSP features require it:
        
        - Rowan integration for true persistent trees
        - Concurrent read access with immutable nodes
        - Incremental reparsing support
        - Full XPath 3.1 implementation

:: note :: This specification was implemented across commits fe664bf, c981f54, b8d2165, and ee4e372 in four phases, delivering a complete tree traversal and query system.


