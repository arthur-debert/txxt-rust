# TXXT Token Reference

:: title :: Complete reference of all TXXT tokens, their variations, and implementation gotchas

A comprehensive guide to every syntactic element in the TXXT format, including edge cases and parser behavior.

## Sequence Markers (List Items)

Markers that introduce list items. Must appear at column 0 and be followed by a space.

### Plain Style
- Plain marker: `-` (dash + space)
    - Example: `- First item`
    - Edge case: `--` is not a valid marker

### Numerical Style  
- Decimal numbers: `1.`, `42.`, `999.` (digits + period + space)
    - Example: `1. First numbered item`
    - Edge case: `1..` (double period) is invalid
    - Edge case: `1 ` (no period) is invalid
    - Gotcha: Numbers don't need to be sequential

### Alphabetical Style
- Lowercase letters: `a.`, `b.`, `z.` (letter + period + space)
    - Example: `a. First alpha item`
    - Limited to single letters only
- Uppercase letters: `A.`, `B.`, `Z.` (letter + period + space)
    - Example: `A. First upper alpha item`
- Parenthetical form: `a)`, `b)`, `A)`, `Z)` (letter + parenthesis + space)
    - Example: `a) Parenthetical alpha item`

### Roman Numeral Style
- Lowercase roman: `i.`, `ii.`, `iii.`, `iv.`, `v.`, `vi.`, `vii.`, `viii.`, `ix.`, `x.`
    - Example: `i. First roman item`
    - Limited to 1-10 range in current implementation
- Uppercase roman: `I.`, `II.`, `III.`, `IV.`, `V.`, `VI.`, `VII.`, `VIII.`, `IX.`, `X.`
    - Example: `I. First upper roman item`
- Parenthetical form: `i)`, `ii)`, `I)`, `II)`
    - Example: `i) Parenthetical roman item`

### Edge Cases and Gotchas
- **Position requirement**: Must be at column 0 (start of line)
- **Space requirement**: Must be followed by exactly one space
- **Invalid patterns**: 
    - `1)` for numbers (should use `.` not `)`)
    - `aa.` for multi-letter alphabetical
    - `iiii.` for invalid roman numerals
- **Style consistency**: First marker determines style for that list level

## Annotation Markers

Double colons `::` used for metadata and document annotations.

### Basic Syntax
- Simple form: `::` 
    - Must be exactly two colons
    - `:::` (triple colon) is NOT an annotation marker
    - Used in patterns like `:: label :: content`

### Complete Annotation Patterns
- Basic annotation: `:: title :: Document title here`
- With parameters: `:: author:role=primary,affiliation="University" :: Jane Doe`
- Empty label: `:: :: Some content` (valid but unusual)
- Label only: `:: metadata ::` (no immediate content)

### Multi-line Annotations
- Block form:
    ```
    :: warning ::
        This is a multi-line warning
        that spans several lines
    ```

### Edge Cases
- **Not verbatim content**: `::` is always parsed as annotation, never verbatim
- **Triple colon ambiguity**: `:::` could be `:` + `::` but current implementation rejects
- **Empty patterns**: `:: ::` (just spaces) creates empty annotation
- **Nested not supported**: Cannot have `::` inside annotation content

## Reference Markers

Square bracket notation `[target]` for links and references.

### File References
- Relative paths: `[./file.txxt]`, `[../other/file.txxt]`
- Absolute paths: `[/full/path/to/file.txxt]`
- Gotcha: No validation of file existence at parse time

### Section References  
- Numbered sections: `[#2]`, `[#2.1]`, `[#2.1.3]`
- Negative indexing: `[#-1]` (last section), `[#-1.2]` (second subsection of last)
- Named anchors: `[#anchor-name]` (via parameter system)

### URL References
- Full URLs: `[https://example.com]`, `[http://site.org/path]`
- Bare domains: `[example.com]`, `[sub.domain.org]`
- Email addresses: `[user@domain.com]`

### Footnote-Style References
- Naked numbers: `[1]`, `[2]`, `[42]`
- **Auto-conversion**: `[3]` becomes `[#-1.3]` (3rd subsection of last section)
- **Gotcha**: These are section references, not traditional footnotes

### Citation References
- Academic style: `[@smith2023]`, `[@doe2024]`
- Multiple citations: `[@smith2023; @jones2025]`
- With locators: `[@smith2023, p. 45]`, `[@doe2024, ch. 3, fig. 2]`
- Requires `:: bibliography :: file.bib` annotation

### Edge Cases
- **No nesting**: Cannot contain other formatting inside references
- **No anchor text**: Relies on preceding word convention
- **Resolution deferred**: Parser doesn't validate targets exist

## Text Content Tokens

Regular alphanumeric content and words.

### Basic Text
- Alphanumeric sequences: `hello`, `world123`, `file_name`
- **Precedence**: Text tokens tried before Identifier tokens
- **Whitespace handling**: Spaces separate text tokens

### Identifier vs Text Distinction
- **Text**: General content words, list item content
- **Identifier**: Variable names, labels (tried after Text)
- **Implementation note**: Order matters in tokenizer

## Inline Formatting Tokens

Markers for text styling within content.

### Bold Text
- Syntax: `*text*` (asterisks around content)
- Example: `This is *bold* text`
- **No spaces**: Must be `*word*` not `* word *`

### Italic Text  
- Syntax: `_text_` (underscores around content)
- Example: `This is _italic_ text`
- **No spaces**: Must be `_word_` not `_ word _`

### Code Text
- Syntax: `` `text` `` (backticks around content)
- Example: ``This is `code` text``
- **No spaces**: Must be `` `code` `` not `` ` code ` ``

### Math Text
- Syntax: `#formula#` (hash/pound signs around content)
- Example: `This is #E=mc^2# math`
- **No spaces**: Must be `#x=y#` not `# x=y #`

### Nesting and Limitations
- **Nesting allowed**: `*bold with _italic_ inside*`
- **No line spanning**: Cannot cross line boundaries
- **Unclosed pairs**: Treated as literal text

## Verbatim Block Tokens

Markers for code blocks and preserved content.

### Start Markers
- Title with colon: `Code example:` (followed by indented content)
- Just colon: `:` (anonymous verbatim block)
- **Distinction**: Single `:` for verbatim, `::` for definitions

### Content Tokens
- **VerbatimContent**: Exact preservation of whitespace and formatting
- **No parsing**: Content inside verbatim blocks bypasses normal token parsing

### End Markers (Labels)
- Simple label: `(python)`, `(javascript)`, `(text)`
- With parameters: `(python:version=3.11,author="Jane")`
- Anonymous: `()` (no label)

### Verbatim Styles
- **In-flow**: Content indented +1 from current level
- **Stretched**: Content starts at column 0 for maximum width

## Definition Markers

Special syntax for term definitions.

### Definition Syntax
- Pattern: `term ::` (double colon at end of line)
- **Distinction**: End-of-line `::` for definitions vs inline `::` for annotations
- Content indented +1 level

### Examples
- Simple: `Parser ::` (followed by indented explanation)
- With formatting: `*Important Term* ::` (term can have inline formatting)

## Structural Tokens

Tokens for document structure and whitespace.

### Line Structure
- **Newline**: `\n` characters (line breaks)
- **BlankLine**: Empty lines (multiple collapsed to single)
- **Indent**: Increased indentation level
- **Dedent**: Decreased indentation level

### Special Tokens
- **Dash**: Standalone `-` character (not in sequence marker context)
- **FootnoteNumber**: Numeric references like `[1]`, `[2]`
- **Eof**: End of file marker

## Parameter System

Shared syntax for annotations and verbatim blocks.

### Parameter Syntax
- Key-value pairs: `key=value,key2=value2`
- Quoted values: `key="value with spaces",key2='single quoted'`
- Namespaced keys: `org.example.config=value`

### Quoting and Escaping
- **When to quote**: Values with spaces, commas, special characters
- **Escape sequences**: Backslash `\` within quoted strings
- **Example**: `key="value with \"quotes\" and \\backslashes"`

### Edge Cases
- **Empty values**: `key=,key2=value` (empty first value)
- **Boolean shorthand**: Just `key` implies `key=true`
- **Complex nesting**: Parameters can contain annotation-like syntax

## Character-Level Tokens and Escaping

Low-level syntax elements.

### Escape Sequences
- **Backslash escaping**: `\` removes special meaning from next character
- **Common escapes**: `\*not bold\*`, `\- not list`, `\\` for literal backslash
- **Line breaks**: Cannot escape newlines to continue lines

### Unicode and Encoding
- **UTF-8 required**: All text must be valid UTF-8
- **Line endings**: Unix LF preferred, CRLF accepted
- **Tab handling**: Tabs converted to 4 spaces
- **BOM**: Byte order mark stripped if present

## Implementation Gotchas

Critical parsing behaviors and edge cases.

### Precedence Issues
- **Order matters**: Text tried before Identifier in tokenizer
- **Context sensitivity**: `::` behavior depends on position
- **Greedy matching**: Longest valid token wins

### Ambiguous Cases
- **Triple colons**: `:::` handling varies by implementation
- **Nested markers**: `*bold with [reference] inside*` - reference wins
- **Incomplete patterns**: `:: title` without closing `::` - graceful degradation

### Whitespace Sensitivity
- **Significant spaces**: List markers must have trailing space
- **Indentation rules**: Exact column positioning matters
- **Line boundaries**: Most tokens cannot span lines

### Error Recovery
- **Graceful degradation**: Invalid syntax becomes plain text
- **No exceptions**: Parser never fails, produces best-effort tokens
- **Consistent behavior**: Same input always produces same tokens

## Current Implementation Status

:: status :: Analysis of implemented vs specified tokens

### ✅ Fully Implemented
- SequenceMarker (all styles: plain, numerical, alphabetical, roman)
- AnnotationMarker (basic `::` syntax)
- Text (regular content words)
- Identifier (variable names, labels)
- Eof (end of file marker)

### ⚠️ Partially Implemented  
- RefMarker (structure exists but recognition logic missing)
- FootnoteNumber (structure exists but recognition logic missing)
- VerbatimStart (structure exists but recognition logic missing)
- VerbatimContent (structure exists but recognition logic missing)

### ❌ Not Yet Implemented
- Newline (line break handling)
- BlankLine (empty line handling)  
- Indent/Dedent (structural indentation)
- Dash (standalone dash characters)
- Inline formatting markers (*bold*, _italic_, `code`, #math#)
- Citation parsing ([@reference] syntax)

### 🔧 Implementation Notes
- **Token precedence**: Text before Identifier (recently fixed)
- **Whitespace handling**: Basic space skipping implemented
- **Position tracking**: Full SourceSpan support for language server
- **Backtracking**: Proper failed token recovery implemented

The tokenizer provides a solid foundation with sequence markers and annotation markers fully working. The next phase should focus on reference markers and inline formatting tokens.