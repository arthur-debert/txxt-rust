:: title :: txxt Semantic Tokens Reference
:: author :: Arthur Debert
:: pub-date :: 2025-10-18

This document is part of the txxt syntax tree documentation. Together with @grammar.txxt, it defines the complete syntax and structure of the txxt format.

- @scanner-tokens.txxt defines the low-level scanner tokens
- @semantic-tokens.txxt (this document) defines semantic node types
- @grammar.txxt defines how blocks are constructed from scanner tokens

This document defines the semantic tokens used in the txxt parsing pipeline. Semantic tokens are higher-level constructs that bridge the gap between low-level scanner tokens and block elements, providing structured components for parsing stages.

1. Introduction

    The Semantic Token Parsing phase transforms scanner tokens into semantic tokens. This intermediate representation provides structured, reusable components that make subsequent block parsing simpler and more direct.

    Semantic tokens describe the *syntactic shape* of content, not its final semantic role (e.g., a paragraph vs. a definition term). They bridge the gap between format-only scanner tokens and semantic block elements.

2. Semantic Token Definitions

    TxxtMarker::
        The fundamental :: marker used across annotations, definitions, and verbatim blocks.
        Identifies txxt structural elements and provides disambiguation anchor points.
        Essential for recognizing txxt syntax vs plain text.

    Colon::
        Colon punctuation marker used for parameter separation.
        Preserves syntactic meaning for parameter parsing and error reporting.
        Allows AST construction phase to identify misplaced syntactic markers with precision.

    Label::
        Structured identifier component for annotations and verbatim blocks.
        Supports namespaced identifiers like "python", "org.example.custom".
        Reusable across annotation labels and verbatim labels.

    Parameters::
        Key-value metadata component used in annotations and verbatim elements.
        Structured parameter list with proper key-value pair parsing.
        Example: "version=3.11,style=functional,author=\"Jane Doe\""

    Sequence Marker::
        List and session numbering component.
        Handles numeric (1.), alphabetic (a.), roman (i.), and plain (-) markers,
        in both regular (2.) and extended (1.3.b) forms.
        Critical for session vs list disambiguation logic, and between lists and paragraphs.

    Text Span::
        Basic text content component without special formatting.
        Building block for larger line constructs.
        Preserves source span information for error reporting.

    Sequence Text Line::
        Line beginning with sequence marker followed by text content.
        Combines Sequence Marker and Text Span components.
        Used for list items, session titles, and numbered paragraphs.

        Structure:
        - indentation_chars: Leading whitespace before the marker (implements the wall concept)
        - marker: The sequence marker component
        - content: The text content following the marker
        - span: Source span covering the entire line

        The indentation_chars field contains structural padding (empty for top-level,
        "    " for indented content, etc.). This separates STRUCTURAL indentation from
        SEMANTIC content, ensuring the parser never sees structural whitespace.

    Plain Text Line::
        Simple text content without special markers or structure.
        Contains single Text Span component.
        Default fallback for unstructured content.

        Structure:
        - indentation_chars: Leading whitespace before the content (implements the wall concept)
        - content: The text content component
        - span: Source span covering the entire line

        The indentation_chars field contains structural padding (empty for top-level,
        "    " for indented content, etc.). This separates STRUCTURAL indentation from
        SEMANTIC content, ensuring the parser never sees structural whitespace.

    Ignore Line::
        Preserved exactly as written without txxt processing.
        Stored as raw string with source span tracking.
        Consumed by a verbatim block.

    Blank Line::
        Line containing only whitespace or completely empty.
        Critical for whitespace enclosure detection in sessions vs lists.
        Sessions require blank line separation; lists cannot have blank lines between items.

    Indent::
        Indentation marker passed through unchanged from scanner tokens.
        Marks the beginning of a new indentation level.
        Used for block structure and nesting.

    Dedent::
        Dedentation marker passed through unchanged from scanner tokens.
        Marks the end of an indentation level.
        Used for block structure and nesting.

    Annotation::
        Annotation semantic token combining txxt markers with labels and optional content.
        Composition: TxxtMarker + Whitespace + Text + Whitespace + TxxtMarker + Text?
        Used for metadata elements that attach structured information to other elements.

    Definition::
        Definition semantic token combining text with txxt markers.
        Composition: Text + Whitespace + TxxtMarker (simple) or Text + Colon + Text + Whitespace + TxxtMarker (parameterized)
        Used for structured elements that define terms, concepts, and entities.

    Verbatim Block::
        Verbatim block semantic token using wall architecture.
        Composition: VerbatimTitle + IndentationWall + IgnoreTextSpan + VerbatimLabel
        Used for content that preserves exact formatting and spacing.

3. The Wall Concept for Indentation

    The wall concept is a fundamental architecture pattern for handling indented content
    in txxt. It separates STRUCTURAL indentation (padding) from SEMANTIC content.

    3.1. Wall Definition

        The "wall" is the position where actual content starts after indentation.
        Everything before the wall is structural padding, not content.

        Example:
            1. Session Title

                |This is content at the wall
                |Second line also at the wall

        The wall (marked by |) is at column 4 relative to the session title.
        The leading "    " (4 spaces) is STRUCTURAL, not SEMANTIC.

    3.2. Implementation in Tokens

        Line-level semantic tokens (PlainTextLine, SequenceTextLine) implement the wall
        concept through the indentation_chars field:

        Scanner tokens preserve everything:
        - Indent (structural marker)
        - Whitespace("    ") (physical spaces)
        - Text("This") (content at wall)

        High-level tokens separate structure from content:
        - Indent (structural token)
        - PlainTextLine {
            indentation_chars: "    ",  // Wall padding (STRUCTURAL)
            content: "This is content...",  // Content at wall (SEMANTIC)
          }

    3.3. Benefits

        - Scanner tokens: Preserve exact positions for LSP features and error reporting
        - High-level tokens: Make structure explicit via indentation_chars
        - Parser: Sees content at the wall, never sees structural padding
        - Consistency: Same architecture across all line-level elements

    3.4. Relationship to Verbatim Blocks

        The wall concept originated in verbatim blocks (see @verbatim.txxt section 5.2).
        It has been extended to ALL line-level content for consistency:
        - Verbatim blocks: Use IndentationWall scanner token
        - Regular content: Use indentation_chars field in line tokens

        This ensures uniform handling of indented content throughout the parser.

4. Token Composition Patterns

    Semantic tokens are composed from scanner tokens using well-defined patterns:

    4.1. Annotation Composition

        Annotations combine txxt markers with labels and optional content:
        `TxxtMarker` + `Whitespace` + `Text` + `Whitespace` + `TxxtMarker` + `Text`?

    4.2. Definition Composition

        Definitions combine text with txxt markers, optionally with parameters:
        `Text` + `Whitespace` + `TxxtMarker` (simple definition)
        `Text` + `Colon` + `Text` + `Whitespace` + `TxxtMarker` (parameterized definition)

    4.3. Verbatim Composition

        Verbatim blocks use wall architecture:
        `VerbatimTitle` + `IndentationWall` + `IgnoreTextSpan` + `VerbatimLabel`

    4.4. Parameter Composition

        Parameters combine identifiers, equals signs, and values:
        `Identifier` + `Equals` + `Value` + `Comma`?

    4.5. Structural Token Composition

        Structural tokens are passed through unchanged from scanner tokens:
        `Indent` and `Dedent` tokens preserve indentation structure
        `BlankLine` tokens preserve whitespace structure

    3.6. Complex Semantic Token Composition

        Complex semantic tokens combine multiple simpler tokens:
        - `Annotation`: Combines multiple tokens into structured metadata
        - `Definition`: Combines text and markers into structured definitions
        - `VerbatimBlock`: Combines verbatim components into content blocks

4. Separation of Concerns

    The semantic token layer provides clear separation between:
    - Format recognition (scanner tokens)
    - Syntactic structure (semantic tokens)
    - Semantic meaning (block elements)

    This separation enables:
    - Cleaner parsing logic
    - Better error handling
    - Easier testing and debugging
    - More maintainable code

5. File Organization

    Semantic tokens (high-level tokens) are organized in the CST module:

    5.1. High-Level Token Definitions

        - `src/cst/high_level_tokens.rs`: HighLevelToken enum and types
        - `src/cst/primitives.rs`: Shared Position and SourceSpan types
        - `src/lexer/pipeline/`: High-level token processing

    5.2. CST vs AST Architecture

        The Concrete Syntax Tree (CST) contains all token types:
        - Scanner tokens (low-level, character-precise)
        - High-level tokens (semantic tokens, line-level)

        The Abstract Syntax Tree (AST) contains semantic elements:
        - Block elements (ParagraphBlock, ListBlock, SessionBlock)
        - Inline elements (TextSpan, BoldSpan, CitationSpan)
        - Container elements (ContentContainer, SessionContainer)

:: note :: This semantic tokens reference defines the intermediate representation used in txxt parsing. For complete block grammar, see @grammar.txxt.
